<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="Angelo Pesce (@kenpex) recently tweeted:
This is a calibration poll. Please don't spoil the answer, RT appreciated - Do you know how a GPU knows which mips to fetch when a regular tex2D(tex,uv) is called with trilinear filtering?
— c0de517e/AngeloPesce (@kenpex) December 3, 2019 I would have counted myself as &lsquo;not sure&rsquo;, but I had a pretty good idea what it would involve and I was also pretty sure I could figure it out.">
<meta property="og:title" content="Calculating LOD">
<meta property="og:description" content="Angelo Pesce (@kenpex) recently tweeted:
This is a calibration poll. Please don't spoil the answer, RT appreciated - Do you know how a GPU knows which mips to fetch when a regular tex2D(tex,uv) is called with trilinear filtering?
— c0de517e/AngeloPesce (@kenpex) December 3, 2019 I would have counted myself as &lsquo;not sure&rsquo;, but I had a pretty good idea what it would involve and I was also pretty sure I could figure it out.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://graemephi.github.io/posts/calculating-lod/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2019-12-31T13:29:00+00:00">
<meta property="article:modified_time" content="2019-12-31T13:29:00+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Calculating LOD">
<meta name=twitter:description content="Angelo Pesce (@kenpex) recently tweeted:
This is a calibration poll. Please don't spoil the answer, RT appreciated - Do you know how a GPU knows which mips to fetch when a regular tex2D(tex,uv) is called with trilinear filtering?
— c0de517e/AngeloPesce (@kenpex) December 3, 2019 I would have counted myself as &lsquo;not sure&rsquo;, but I had a pretty good idea what it would involve and I was also pretty sure I could figure it out.">
<meta name=twitter:site content="@graemephi">
<meta name=generator content="Hugo 0.90.0-DEV">
<title>Calculating LOD - graeme. hello</title>
<link href=/css/katex.min.css rel=stylesheet type=text/css>
<style>body{background-color:#fffdfc;font-family:Georgia,times new roman,serif;font-size:1em;margin:0 2em;line-height:1.4em}body *{margin-left:auto;margin-right:auto}a.footnote-backref{visibility:hidden;font-size:.66em}a.footnote-backref::before{visibility:visible;content:"back"}.content{flex:initial;width:42em}@media(max-width:49.1228em){.content{width:85vw}}.about{margin:0}.page-header{align-items:center;display:flex;justify-content:space-between}.name{margin-left:1em;margin-right:auto}.post-header{align-items:baseline;color:#5a5857;display:flex;flex-flow:wrap;justify-content:space-between;line-height:.5em}a{color:#000;text-decoration-color:#5a5857;text-decoration:underline}a:hover{color:#ffa000;text-decoration-color:#d18400}.icon:hover{fill:#ffa000}h1>a,h2>a,h3>a,h4>a,a.icon{text-decoration:none}hr{border:0;height:0;border-top:1px solid rgba(87,44,0,.1)}.svgi>svg{vertical-align:middle}code{font-family:consolas;font-size:.8em;overflow-x:scroll;max-width:100%}blockquote.aside{padding:.5em 1.5em;margin:1em -1em;display:block;border-radius:5px;background-color:#fbf3ef;border-style:outset;border-color:hsla(20,58%,46%,4%)}.tags{align-items:baseline;color:#5a5857;display:flex;flex-flow:wrap;line-height:1em;list-style-type:none;padding:0}.tags.post-tags{font-size:.9em;justify-content:flex-end;margin:0}.tags.all-tags{justify-content:flex-start;margin:-1em 0}.list-tags{margin:-1em 0}.tags a{color:#2d2c2b}.post-tags a{text-decoration:none}.tags>li{margin:0 .1em}.post{margin:2em auto}.post img{display:block;margin:0 auto;max-width:calc(100vw - 1em);height:auto}.text-align-right{text-align:right}.rss-link{font-size:.8em;text-align:right}.post-title{line-height:1em}.katex{font-size:large}pre.terminal,pre>code.language-terminal{background:#272822;padding:.66em 1em;padding:1em 2em;margin:1em -1em;color:#f8f8f2;display:block;border-radius:5px}p code{background:#feeee7;padding:.1em .2em}.katex-display>.katex{font-size:larger}.highlight>pre{position:relative;padding:1em 2em;margin:1em -1em;overflow-x:auto}.highlight code{font-size:.83em}.img-flex{background-color:#fffdfc;display:flex;justify-content:center;flex-wrap:wrap;position:relative;width:100vw;left:calc(50% - 50vw)}.img-flex>img{margin:.5em}@media(min-width:84em){.img-flex{width:84em;left:calc(50% - 42em)}}.katex-display>.katex{max-width:100%;overflow-x:scroll}table{margin:1em -1em;border-collapse:separate;border-spacing:0;border-radius:5px;width:calc(100% + 2em);overflow-x:scroll;border:1px solid hsla(20,58%,46%,.2)}th,td{padding:.5em 1em;border-right:1px solid hsla(20,58%,46%,.1)}th{font-weight:700;border-bottom:1px solid hsla(20,58%,46%,.1);background-color:#fbf3ef;text-align:left}td{border-bottom:1px solid hsla(20,58%,46%,.1)}tr:last-child td{border-bottom:none}td:last-child,th:last-child{border-right:none}</style>
</head>
<body>
<div class=content>
<header class=page-header>
<span style=display:inline-flex;flex-direction:column>
<h3 class=page-title><a href=/><span>graeme. hello</span></a></h3>
</span>
<span class=links>
<a href=https://github.com/graemephi class="github icon" title=Github><svg height="30" style="enable-background:new 0 0 512 512" viewBox="0 0 512 512" width="30" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M256 32C132.3 32 32 134.8 32 261.7c0 101.5 64.2 187.5 153.2 217.9 11.2 2.1 15.3-5 15.3-11.1.0-5.5-.2-19.9-.3-39.1-62.3 13.9-75.5-30.8-75.5-30.8-10.2-26.5-24.9-33.6-24.9-33.6-20.3-14.3 1.5-14 1.5-14 22.5 1.6 34.3 23.7 34.3 23.7 20 35.1 52.4 25 65.2 19.1 2-14.8 7.8-25 14.2-30.7-49.7-5.8-102-25.5-102-113.5.0-25.1 8.7-45.6 23-61.6-2.3-5.8-10-29.2 2.2-60.8.0.0 18.8-6.2 61.6 23.5 17.9-5.1 37-7.6 56.1-7.7 19 .1 38.2 2.6 56.1 7.7 42.8-29.7 61.5-23.5 61.5-23.5 12.2 31.6 4.5 55 2.2 60.8 14.3 16.1 23 36.6 23 61.6.0 88.2-52.4 107.6-102.3 113.3 8 7.1 15.2 21.1 15.2 42.5.0 30.7-.3 55.5-.3 63 0 6.1 4 13.3 15.4 11C415.9 449.1 480 363.1 480 261.7 480 134.8 379.7 32 256 32z"/></svg>
</a>
<a href=https://mastodon.gamedev.place/@graeme class="mastodon icon" title=Mastodon><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 418 512" fill="currentcolor" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M433 179.11c0-97.2-63.71-125.7-63.71-125.7-62.52-28.7-228.56-28.4-290.48.0.0.0-63.72 28.5-63.72 125.7.0 115.7-6.6 259.4 105.63 289.1 40.51 10.7 75.32 13 103.33 11.4 50.81-2.8 79.32-18.1 79.32-18.1l-1.7-36.9s-36.31 11.4-77.12 10.1c-40.41-1.4-83-4.4-89.63-54a102.54 102.54.0 01-.9-13.9c85.63 20.9 158.65 9.1 178.75 6.7 56.12-6.7 105-41.3 111.23-72.9 9.8-49.8 9-121.5 9-121.5zm-75.12 125.2h-46.63v-114.2c0-49.7-64-51.6-64 6.9v62.5h-46.33V197c0-58.5-64-56.6-64-6.9v114.2H90.19c0-122.1-5.2-147.9 18.41-175 25.9-28.9 79.82-30.8 103.83 6.1l11.6 19.5 11.6-19.5c24.11-37.1 78.12-34.8 103.83-6.1 23.71 27.3 18.4 53 18.4 175z"/></svg>
</a>
</span>
</header>
<div class=post-header>
<h1 class=post-title><a href=/posts/calculating-lod/>Calculating LOD</a></h1>
</div>
<div class=text-align-right>
<span class=date>December 31, 2019</span>
<br>
<ul class="tags post-tags">
[
<li><a href=/tags/graphics/>graphics</a></li>
]
</ul>
</div>
<div class=post>
<p>Angelo Pesce (@kenpex) recently tweeted:</p>
<blockquote class=twitter-tweet><p lang=en dir=ltr>This is a calibration poll. Please don't spoil the answer, RT appreciated - Do you know how a GPU knows which mips to fetch when a regular tex2D(tex,uv) is called with trilinear filtering?</p>— c0de517e/AngeloPesce (@kenpex) <a href="https://twitter.com/kenpex/status/1201946673091448832?ref_src=twsrc%5Etfw">December 3, 2019</a></blockquote>
<p>I would have counted myself as &lsquo;not sure&rsquo;, but I had a pretty good idea what it would involve and I was also pretty sure I could figure it out. Instead of just being pretty sure about it I decided to test my intuitions against a GPU and made <a href=https://www.shadertoy.com/view/3ldGR2>this shadertoy</a>.</p>
<p>Most of the code is machinery to get a triangle up that we can rotate around in 3D space. I find it vaguely amusing to write a triangle rasteriser in a fragment shader, so that&rsquo;s what I did. This post is just about LOD, so if you&rsquo;re interested in how the rasteriser works I recommend starting with Fabien Giesen&rsquo;s <a href=https://fgiesen.wordpress.com/2013/02/06/%5Dthe-barycentric-conspirac/>The Barycentric Conspiracy</a>.</p>
<p>So, mipmaps: we have a texture with a series of successively smaller mip levels, each filtered properly prior to rendering to avoid aliasing. In this post I&rsquo;m just going to assume textures are always square, and always a power of two in size. These restrictions can be lifted but I don&rsquo;t really see why you would, except maybe to save space when using very large non-square textures.</p>
<h2 id=2d>2D</h2>
<p>I&rsquo;d already done this in 2D for <a href=https://github.com/graemephi/starfield>a small project of mine</a>, so this coloured my intuition a bit.</p>
<img src=/posts/calculating-lod/6.png width=502 height=532 loading=lazy>
<p>I was just drawing textures in squares of different orientations and sizes&ndash;it turns out an easy way to draw stars is to put a single very bright pixel in a big texture, and let mipmaps take care of the rest. So, here, we just have to do <code>log2(texture_size / max(target_width, target_height))</code>, that is, the <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\log_2</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.93858em;vertical-align:-.24414em></span><span class=mop><span class=mop>lo<span style=margin-right:.01389em>g</span></span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.20696799999999996em><span style=top:-2.4558600000000004em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.24414em><span></span></span></span></span></span></span></span></span></span> of the inverse of the amount of scaling applied to the texture. To see why, each mip has <em>relative</em> sizes <code>1/1, 1/2, 1/4, ..., 1/n</code>. We can get the relative size of the target rect by looking at its width and height, and we want to turn that relative size into an index into this list of sizes for which we have mips. So, we need the function <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mo>−</mo><mi>n</mi></mrow></msup><mo>↦</mo><mo>−</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">2^{-n} \mapsto -n</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.782331em;vertical-align:-.011em></span><span class=mord><span class=mord>2</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.771331em><span style=top:-3.063em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span><span class=mspace style=margin-right:.2777777777777778em></span><span class=mrel>↦</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:.66666em;vertical-align:-.08333em></span><span class=mord>−</span><span class="mord mathdefault">n</span></span></span></span>. That&rsquo;s <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\log_2</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.93858em;vertical-align:-.24414em></span><span class=mop><span class=mop>lo<span style=margin-right:.01389em>g</span></span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.20696799999999996em><span style=top:-2.4558600000000004em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.24414em><span></span></span></span></span></span></span></span></span></span>.</p>
<p>Using <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\log_2</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.93858em;vertical-align:-.24414em></span><span class=mop><span class=mop>lo<span style=margin-right:.01389em>g</span></span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.20696799999999996em><span style=top:-2.4558600000000004em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.24414em><span></span></span></span></span></span></span></span></span></span> also takes care of the fractional part of mip selection, so we can do trilinear filtering. If you think about it this is somewhat interesting, because we&rsquo;re blending in a larger mip onto a target we already know is too small to not alias (in general). But having a jump discontuinity between mips looks way worse than low levels of aliasing.</p>
<h2 id=3d>3D</h2>
<p>The main thing about 3D is that the LOD level can change across the surface of a triangle.</p>
<img src=/posts/calculating-lod/stoy.png width=477 height=284 loading=lazy>
<p>We need to think a bit more carefully about what&rsquo;s happening. As we step along pixels in screen space, we also step along texels in texture space. While the former is constant, the latter steps vary in size due to perspective. Reasoning this way works in 2D, too, we just never had to: the constant, screen space step is our <code>1</code> in the series of relative mip sizes, and the relative, texture space step size is the denominator up to <code>n</code>. The question is how to get the step size at a given pixel, given that we shade each pixel independently of its neighbours. Now, I guess if you know the graphics pipeline quite well the answer to this jumps out at you, but I want to be able to justify why you would use the functions you do.</p>
<p>So, in 2D, the texture space step size is constant, and we&rsquo;re able to compute it by assuming we&rsquo;re going to draw the entire texture and comparing its original size with its new width and height in screen space. Now, to get the step size at a point in 3D, we can approximate it by asking about a smaller part of the texture, say a 2x2 patch rather than the entire thing, at that point. To drive the point home here, in 2D we had</p>
<p><span class=katex-display><span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>T</mi><mo stretchy="false">(</mo><mtext mathvariant="bold">0</mtext><mo>+</mo><mtext mathvariant="bold">x</mtext><mo stretchy="false">)</mo><mo>−</mo><mi>T</mi><mo stretchy="false">(</mo><mtext mathvariant="bold">0</mtext><mo stretchy="false">)</mo></mrow><mrow><mo fence="true">∥</mo><mtext mathvariant="bold">x</mtext><mo fence="true">∥</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex"> \frac{ T(\textbf{0} + \textbf{x} ) - T(\textbf{0}) }{ \left\| \textbf{x} \right\| }</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:2.363em;vertical-align:-.936em></span><span class=mord><span class="mopen nulldelimiter"></span><span class=mfrac><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:1.427em><span style=top:-2.314em><span class=pstrut style=height:3em></span><span class=mord><span class=minner><span class="mopen delimcenter" style=top:0>∥</span><span class="mord text"><span class="mord textbf">x</span></span><span class="mclose delimcenter" style=top:0>∥</span></span></span></span><span style=top:-3.23em><span class=pstrut style=height:3em></span><span class=frac-line style=border-bottom-width:.04em></span></span><span style=top:-3.677em><span class=pstrut style=height:3em></span><span class=mord><span class="mord mathdefault" style=margin-right:.13889em>T</span><span class=mopen>(</span><span class="mord text"><span class="mord textbf">0</span></span><span class=mspace style=margin-right:.2222222222222222em></span><span class=mbin>+</span><span class=mspace style=margin-right:.2222222222222222em></span><span class="mord text"><span class="mord textbf">x</span></span><span class=mclose>)</span><span class=mspace style=margin-right:.2222222222222222em></span><span class=mbin>−</span><span class=mspace style=margin-right:.2222222222222222em></span><span class="mord mathdefault" style=margin-right:.13889em>T</span><span class=mopen>(</span><span class="mord text"><span class="mord textbf">0</span></span><span class=mclose>)</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.936em><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>with <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.68333em;vertical-align:0></span><span class="mord mathdefault" style=margin-right:.13889em>T</span></span></span></span> being some transform and <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="bold">x</mtext></mrow><annotation encoding="application/x-tex">\textbf{x}</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.44444em;vertical-align:0></span><span class="mord text"><span class="mord textbf">x</span></span></span></span></span> being one side of the texture, and we&rsquo;re replacing it with</p>
<p><span class=katex-display><span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>T</mi><mo stretchy="false">(</mo><mtext mathvariant="bold">p</mtext><mo>+</mo><mi>h</mi><mtext mathvariant="bold">x</mtext><mo stretchy="false">)</mo><mo>−</mo><mi>T</mi><mo stretchy="false">(</mo><mtext mathvariant="bold">p</mtext><mo stretchy="false">)</mo></mrow><mrow><mi>h</mi><mrow><mo fence="true">∥</mo><mtext mathvariant="bold">x</mtext><mo fence="true">∥</mo></mrow></mrow></mfrac></mrow><annotation encoding="application/x-tex"> \frac{ T(\textbf{p} + h\textbf{x} ) - T(\textbf{p}) }{ h\left\| \textbf{x} \right\| }</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:2.363em;vertical-align:-.936em></span><span class=mord><span class="mopen nulldelimiter"></span><span class=mfrac><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:1.427em><span style=top:-2.314em><span class=pstrut style=height:3em></span><span class=mord><span class="mord mathdefault">h</span><span class=mspace style=margin-right:.16666666666666666em></span><span class=minner><span class="mopen delimcenter" style=top:0>∥</span><span class="mord text"><span class="mord textbf">x</span></span><span class="mclose delimcenter" style=top:0>∥</span></span></span></span><span style=top:-3.23em><span class=pstrut style=height:3em></span><span class=frac-line style=border-bottom-width:.04em></span></span><span style=top:-3.677em><span class=pstrut style=height:3em></span><span class=mord><span class="mord mathdefault" style=margin-right:.13889em>T</span><span class=mopen>(</span><span class="mord text"><span class="mord textbf">p</span></span><span class=mspace style=margin-right:.2222222222222222em></span><span class=mbin>+</span><span class=mspace style=margin-right:.2222222222222222em></span><span class="mord mathdefault">h</span><span class="mord text"><span class="mord textbf">x</span></span><span class=mclose>)</span><span class=mspace style=margin-right:.2222222222222222em></span><span class=mbin>−</span><span class=mspace style=margin-right:.2222222222222222em></span><span class="mord mathdefault" style=margin-right:.13889em>T</span><span class=mopen>(</span><span class="mord text"><span class="mord textbf">p</span></span><span class=mclose>)</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.936em><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>and making <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.69444em;vertical-align:0></span><span class="mord mathdefault">h</span></span></span></span> really small. So, we need two of these for the derivatives in <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.43056em;vertical-align:0></span><span class="mord mathdefault">x</span></span></span></span> and <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.625em;vertical-align:-.19444em></span><span class="mord mathdefault" style=margin-right:.03588em>y</span></span></span></span>, and you can get an approximation of them&ndash;basically this same one here&ndash;in OpenGL with <code>dFdx()</code> and <code>dFdy()</code>.</p>
<p>In the shadertoy, this is all implemented like this.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-glsl data-lang=glsl><span style=color:#75715e>// uv comes in as an interpolated input</span>
<span style=color:#66d9ef>vec2</span> size <span style=color:#f92672>=</span> <span style=color:#66d9ef>vec2</span>(textureSize(iChannel0, <span style=color:#ae81ff>0</span>));

<span style=color:#66d9ef>vec2</span> dx <span style=color:#f92672>=</span> dFdx(uv <span style=color:#f92672>*</span> size);
<span style=color:#66d9ef>vec2</span> dy <span style=color:#f92672>=</span> dFdy(uv <span style=color:#f92672>*</span> size);

<span style=color:#66d9ef>float</span> d <span style=color:#f92672>=</span> max(length(dx), length(dy));
<span style=color:#66d9ef>float</span> lod <span style=color:#f92672>=</span> max(<span style=color:#ae81ff>0.</span>, log2(d));
<span style=color:#66d9ef>vec3</span> col <span style=color:#f92672>=</span> textureLod(tex, p, lod).xyz;</code></pre></div>
<p>Eyeballing the results this seems to work, but if we take the difference between <code>textureLod()</code> with our <code>lod</code> value versus using <code>texture()</code> and scale it up a bit to magnify errors, we get this.</p>
<img src=/posts/calculating-lod/stoy2.png width=477 height=284 loading=lazy>
<p>It should be black. The problem is obvious in retrospect, but rather than thinking too hard about it I had a look through the <a href=https://microsoft.github.io/DirectX-Specs/d3d/archive/D3D11_3_FunctionalSpec.htm#LODCalculation>DX11 Functional Specification</a>, which tells you to do this to the derivative vectors:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-glsl data-lang=glsl><span style=color:#66d9ef>float</span> A <span style=color:#f92672>=</span> dx.y <span style=color:#f92672>*</span> dx.y <span style=color:#f92672>+</span> dy.y <span style=color:#f92672>*</span> dy.y;
<span style=color:#66d9ef>float</span> B <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>2.0</span> <span style=color:#f92672>*</span> (dx.x <span style=color:#f92672>*</span> dx.y <span style=color:#f92672>+</span> dy.x <span style=color:#f92672>*</span> dy.y);
<span style=color:#66d9ef>float</span> C <span style=color:#f92672>=</span> dx.x <span style=color:#f92672>*</span> dx.x <span style=color:#f92672>+</span> dy.x <span style=color:#f92672>*</span> dy.x;
<span style=color:#66d9ef>float</span> F <span style=color:#f92672>=</span> dx.x <span style=color:#f92672>*</span> dy.y <span style=color:#f92672>-</span> dy.x <span style=color:#f92672>*</span> dx.y;
F <span style=color:#f92672>=</span> F<span style=color:#f92672>*</span>F;

<span style=color:#66d9ef>float</span> p <span style=color:#f92672>=</span> A <span style=color:#f92672>-</span> C;
<span style=color:#66d9ef>float</span> q <span style=color:#f92672>=</span> A <span style=color:#f92672>+</span> C;
<span style=color:#66d9ef>float</span> t <span style=color:#f92672>=</span> sqrt(p<span style=color:#f92672>*</span>p <span style=color:#f92672>+</span> B<span style=color:#f92672>*</span>B);

dx.x <span style=color:#f92672>=</span> sqrt(F <span style=color:#f92672>*</span> (t<span style=color:#f92672>+</span>p) <span style=color:#f92672>/</span> (t <span style=color:#f92672>*</span> (q<span style=color:#f92672>+</span>t)));
dx.y <span style=color:#f92672>=</span> sqrt(F <span style=color:#f92672>*</span> (t<span style=color:#f92672>-</span>p) <span style=color:#f92672>/</span> (t <span style=color:#f92672>*</span> (q<span style=color:#f92672>+</span>t))) <span style=color:#f92672>*</span> sign(B);
dy.x <span style=color:#f92672>=</span> sqrt(F <span style=color:#f92672>*</span> (t<span style=color:#f92672>-</span>p) <span style=color:#f92672>/</span> (t <span style=color:#f92672>*</span> (q<span style=color:#f92672>-</span>t))) <span style=color:#f92672>*</span> <span style=color:#f92672>-</span>sign(B);
dy.y <span style=color:#f92672>=</span> sqrt(F <span style=color:#f92672>*</span> (t<span style=color:#f92672>+</span>p) <span style=color:#f92672>/</span> (t <span style=color:#f92672>*</span> (q<span style=color:#f92672>-</span>t)));</code></pre></div>
<h2 id=ellipses>Ellipses</h2>
<p>The source it references only as [Heckbert 89] turns out to be a master&rsquo;s thesis, <em>Fundamentals of Texture Mapping and Image Warping</em>, which includes this in its appendices. The DX11 spec says it gives you a &ldquo;proper orthogonal Jacobian matrix&rdquo;, where proper is not a technical term. So, this is looking at the projection as a 2D transform from a point <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x, y)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class=mopen>(</span><span class="mord mathdefault">x</span><span class=mpunct>,</span><span class=mspace style=margin-right:.16666666666666666em></span><span class="mord mathdefault" style=margin-right:.03588em>y</span><span class=mclose>)</span></span></span></span> in screen space to a point <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u, v)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class=mopen>(</span><span class="mord mathdefault">u</span><span class=mpunct>,</span><span class=mspace style=margin-right:.16666666666666666em></span><span class="mord mathdefault" style=margin-right:.03588em>v</span><span class=mclose>)</span></span></span></span> in texture space. Now, it&rsquo;s not linear, so you can&rsquo;t represent it with a 2x2 matrix, but you can look at its derivative to get a linear approximation at a point. That&rsquo;s the Jacobian, and we can construct it by just putting our derivative vectors in the columns of a matrix. But this Jacobian won&rsquo;t be proper.</p>
<p>Basically, the issue is that up until now I&rsquo;ve been neglecting to consider off-axis scaling. To solve this, we want to look at how the unit circle is transformed, not just the axes. That is, we look at the ellipse formed by applying the Jacobian to the unit circle. Weirdly, a pretty good explanation of this idea can be found in the Wikipedia article on <a href=https://en.wikipedia.org/wiki/Singular_value_decomposition#Intuitive_interpretations>singular value decomposition</a>. Anyway, here&rsquo;s <a href=https://www.shadertoy.com/view/ttc3DX>a shadertoy</a> showing how the above code modifies the axes:</p>
<img src=/posts/calculating-lod/ellipse.png width=640 height=360 loading=lazy>
<p>The right ellipse&rsquo;s axes have been obtained by orthogonalising those on the left. The important thing is that both pairs of axes describe the same ellipse. The reason I went through the effort of creating that shadertoy, though, is because I wanted to check that putting those axes into the columns of two matrices would actually give you matrices that created the same ellipse. Because it&rsquo;s a completely different transform, right, one of them isn&rsquo;t even orthogonal! Of course, it does give you the same ellipse, and I guess the reason why that&rsquo;s possible is obvious: each point on the plane is sent to a different place in either matrix, but the <em>unit circle</em> traces out the same ellipse for both. To that end, I&rsquo;ve coloured each point by its original position inside the unit circle.</p>
<p>What this gives you is the maximum scaling in all directions, not just the directions the texture&rsquo;s <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.43056em;vertical-align:0></span><span class="mord mathdefault">x</span></span></span></span> and <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.625em;vertical-align:-.19444em></span><span class="mord mathdefault" style=margin-right:.03588em>y</span></span></span></span> axes have been mapped to in screen space.</p>
<p>Now, applying that correction, we&rsquo;re much closer:</p>
<img src=/posts/calculating-lod/stoy3.png width=477 height=284 loading=lazy>
<p>Still not perfect, though. I&rsquo;m not sure what&rsquo;s missing. DX11 allows for approximations here, and OpenGL&rsquo;s specification doesn&rsquo;t really say anything at all about it, so maybe that&rsquo;s it. I&rsquo;m really not sure.</p>
<h2 id=blocks>Blocks</h2>
<p>Finally, when I first wrote the rasteriser I did it the natural way, something like</p>
<pre tabindex=0><code>if (inside_triangle) {
    color = calculate_color()
    write_pixel(color)
}
</code></pre><p>But if you look at the shadertoy now, you&rsquo;ll see it&rsquo;s written as</p>
<pre tabindex=0><code>color = calculate_color()
if (inside_triangle) {
    write_pixel(color)
}
</code></pre><p>which looks like it wastes a bunch of effort colouring pixels it never writes. The reason for this is that the <code>dFdx</code> and <code>dFdy</code> functions aren&rsquo;t magic: they really do take an approximation of the derivative by subtracting neighbouring pixel values from each other in 2x2 blocks. Since we&rsquo;re running the shader in parallel for each pixel in the block, different pixels in the block can branch in different directions. At that point, the GPU is missing neighbouring values for <code>dFdx</code>/<code>dFdy</code> to compute derivatives with. The derivative computation breaks down and we can&rsquo;t sample mipmaps at all. On my machine, this gave a LOD value of <code>0</code> which resulted in a seam of aliasing down the edges of triangles. At first I thought this was a bug in the inclusion test, but no, it&rsquo;s just old fashioned <a href=https://www.khronos.org/opengl/wiki/Non-Uniform_Control_Flow#Non-uniform_flow_control>non-uniform flow control</a>.</p>
<h2 id=end>End</h2>
<p>I&rsquo;m kinda disappointed I wasn&rsquo;t able to get the LOD computation exact even after going through DX11 and OpenGL specifications. And it <em>is</em> just the LOD that&rsquo;s wrong&ndash;with fixed LOD, the rasteriser does trilinear filtering down to <code>texelFetch()</code> just fine. Also, I&rsquo;ve not talked about anisotropic filtering at all, which I&rsquo;ve now discovered I know even less about than I thought I did. I&rsquo;d like to know more about how it&rsquo;s implemented on GPUs but it appears to be like, a trade secret, or something.</p>
<p>I think writing this post took longer than writing the shadertoy.</p>
</div>
<blockquote class=aside>
<noscript><p style=margin:auto>There might be <a href=https://utteranc.es>utteranc.es</a> comments here when javascript is on.</p></noscript>
<script src=https://utteranc.es/client.js repo=graemephi/graemephi.github.io issue-term=og:title theme=github-light crossorigin=anonymous async></script>
</blockquote>
<h2>More Posts</h2>
<ol reversed>
<li style=list-style:none>
<a href=https://graemephi.github.io/posts/unique-random-numbers/>Generating Unique Random Numbers</a> (2024-09-27)
</li>
<li style=list-style:none>
<a href=https://graemephi.github.io/posts/modular-forms/>WTF Are Modular Forms</a> (2024-03-25)
</li>
<li style=list-style:none>
<a href=https://graemephi.github.io/posts/some-low-discrepancy-noise-functions/>Some low discrepancy noise functions</a> (2022-08-10)
</li>
<li style=list-style:none>
<a href=https://graemephi.github.io/posts/difference-decay/>Difference Decay</a> (2021-12-29)
</li>
<li style=list-style:none>
<a href=https://graemephi.github.io/posts/stb_ds-string-interning/>stb_ds: string interning</a> (2020-08-27)
</li>
<li style=list-style:none>
<a href=https://graemephi.github.io/posts/deep-sky-object/>deep sky object</a> (2020-05-20)
</li>
<li style=list-style:none>
<a href=https://graemephi.github.io/posts/server-side-katex-with-hugo-part-2/>Server-side KaTeX With Hugo: Part 2</a> (2020-01-19)
</li>
<li style=list-style:none>
<a href=https://graemephi.github.io/posts/static-katex-with-hugo/>Server-side KaTeX With Hugo</a> (2019-12-15)
</li>
<li style=list-style:none>
<a href=https://graemephi.github.io/posts/triangle-dft/>The Discrete Fourier Transform, But With Triangles</a> (2019-12-14)
</li>
<li style=list-style:none>
<a href=https://graemephi.github.io/posts/dumb-tricks-with-phase-inversion/>Dumb Tricks With Phase Inversion</a> (2019-06-02)
</li>
</ol>
<div class=rss-link>
<a href=/index.xml title=RSS>rss</a>
</div>
</div>
</body>
</html>