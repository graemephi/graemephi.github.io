<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="This post has two things:
 Two somewhat obscure non-linear invertible operations that work on only part of a register, and A fast stateless random permutation generator that uses them, and passes some statistical tests for RNGs you may have seen before  The ideas are pretty simple so the hope is you can also get an intuition for how to think about the problem, which is the best thing you can get out of this post.">
<meta property="og:title" content="Generating Unique Random Numbers">
<meta property="og:description" content="This post has two things:
 Two somewhat obscure non-linear invertible operations that work on only part of a register, and A fast stateless random permutation generator that uses them, and passes some statistical tests for RNGs you may have seen before  The ideas are pretty simple so the hope is you can also get an intuition for how to think about the problem, which is the best thing you can get out of this post.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://graemephi.github.io/posts/unique-random-numbers/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2024-09-27T20:08:28+00:00">
<meta property="article:modified_time" content="2024-09-27T20:08:28+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Generating Unique Random Numbers">
<meta name=twitter:description content="This post has two things:
 Two somewhat obscure non-linear invertible operations that work on only part of a register, and A fast stateless random permutation generator that uses them, and passes some statistical tests for RNGs you may have seen before  The ideas are pretty simple so the hope is you can also get an intuition for how to think about the problem, which is the best thing you can get out of this post.">
<meta name=twitter:site content="@graemephi">
<meta name=generator content="Hugo 0.90.0-DEV">
<title>Generating Unique Random Numbers - graeme. hello</title>
<link href=/css/katex.min.css rel=stylesheet type=text/css>
<style>body{background-color:#fffdfc;font-family:Georgia,times new roman,serif;font-size:1em;margin:0 2em;line-height:1.4em}body *{margin-left:auto;margin-right:auto}a.footnote-backref{visibility:hidden;font-size:.66em}a.footnote-backref::before{visibility:visible;content:"back"}.content{width:42em}@media(max-width:49.1228em){.content{width:85vw}}.about{margin:0}.page-header{align-items:center;display:flex;justify-content:space-between}.name{margin-left:1em;margin-right:auto}.post-header{align-items:baseline;color:#5a5857;display:flex;flex-flow:wrap;justify-content:space-between;line-height:.5em}a{color:#000;text-decoration-color:#5a5857;text-decoration:underline}a:hover{color:#ffa000;text-decoration-color:#d18400}.icon:hover{fill:#ffa000}h1>a,h2>a,h3>a,h4>a,a.icon{text-decoration:none}hr{border:0;height:0;border-top:1px solid rgba(87,44,0,.1)}.svgi>svg{vertical-align:middle}code{font-family:consolas;font-size:.8em;overflow-x:scroll;max-width:100%}.tags{align-items:baseline;color:#5a5857;display:flex;flex-flow:wrap;line-height:1em;list-style-type:none;padding:0}.tags.post-tags{font-size:.9em;justify-content:flex-end;margin:0}.tags.all-tags{justify-content:flex-start;margin:-1em 0}.list-tags{margin:-1em 0}.tags a{color:#2d2c2b}.post-tags a{text-decoration:none}.tags>li{margin:0 .1em}.post{margin:2em auto}.post img{display:block;margin:0 auto;max-width:calc(100vw - 1em);height:auto}.text-align-right{text-align:right}.rss-link{font-size:.8em;text-align:right}.post-title{line-height:1em}.katex{font-size:large}pre.terminal,pre>code.language-terminal{background:#272822;padding:.66em 1em;padding:1em 2em;margin:1em -1em;color:#f8f8f2;display:block;border-radius:5px}p code{background:#feeee7;padding:.1em .2em}.katex-display>.katex{font-size:larger}.highlight>pre{position:relative;padding:1em 2em;margin:1em -1em;overflow-x:auto}.highlight code{font-size:.83em}.img-flex{background-color:#fffdfc;display:flex;justify-content:center;flex-wrap:wrap;position:relative;width:100vw;left:calc(50% - 50vw)}.img-flex>img{margin:.5em}@media(min-width:84em){.img-flex{width:84em;left:calc(50% - 42em)}}.katex-display>.katex{max-width:100%;overflow-x:scroll}table{margin:1em -1em;border-collapse:separate;border-spacing:0;border-radius:5px;width:calc(100% + 2em);overflow-x:scroll;border:1px solid hsla(20,58%,46%,.2)}th,td{padding:.5em 1em;border-right:1px solid hsla(20,58%,46%,.1)}th{font-weight:700;border-bottom:1px solid hsla(20,58%,46%,.1);background-color:#fbf3ef;text-align:left}td{border-bottom:1px solid hsla(20,58%,46%,.1)}tr:last-child td{border-bottom:none}td:last-child,th:last-child{border-right:none}blockquote{padding:.5em 1.5em;margin:1em .5em;display:block;border-radius:0;background-color:transparent;border-left:3px solid hsla(20,58%,46%,12%);position:relative}blockquote p:first-of-type{margin-top:0}blockquote p:last-of-type{margin-bottom:0}blockquote cite{display:block;font-style:normal;font-size:.9em;text-align:right;margin-top:.5em;color:#272625}blockquote.aside{padding:1em 1.5em;margin:1em -1em;display:block;border-radius:5px;background-color:#fbf3ef;border-style:outset;border-color:hsla(20,58%,46%,4%)}p{margin-bottom:1.1em}.content p,.post p,blockquote p{line-height:1.45em}a{text-decoration-thickness:1px;text-underline-offset:2px}h1,h2,h3,h4{margin-top:1.5em;margin-bottom:.7em;line-height:1.2}p,li,blockquote{letter-spacing:.01em}</style>
</head>
<body>
<div class=content>
<header class=page-header>
<span style=display:inline-flex;flex-direction:column>
<h3 class=page-title><a href=/><span>graeme. hello</span></a></h3>
</span>
<span class=links>
<a href=https://github.com/graemephi class="github icon" title=Github><svg height="30" style="enable-background:new 0 0 512 512" viewBox="0 0 512 512" width="30" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M256 32C132.3 32 32 134.8 32 261.7c0 101.5 64.2 187.5 153.2 217.9 11.2 2.1 15.3-5 15.3-11.1.0-5.5-.2-19.9-.3-39.1-62.3 13.9-75.5-30.8-75.5-30.8-10.2-26.5-24.9-33.6-24.9-33.6-20.3-14.3 1.5-14 1.5-14 22.5 1.6 34.3 23.7 34.3 23.7 20 35.1 52.4 25 65.2 19.1 2-14.8 7.8-25 14.2-30.7-49.7-5.8-102-25.5-102-113.5.0-25.1 8.7-45.6 23-61.6-2.3-5.8-10-29.2 2.2-60.8.0.0 18.8-6.2 61.6 23.5 17.9-5.1 37-7.6 56.1-7.7 19 .1 38.2 2.6 56.1 7.7 42.8-29.7 61.5-23.5 61.5-23.5 12.2 31.6 4.5 55 2.2 60.8 14.3 16.1 23 36.6 23 61.6.0 88.2-52.4 107.6-102.3 113.3 8 7.1 15.2 21.1 15.2 42.5.0 30.7-.3 55.5-.3 63 0 6.1 4 13.3 15.4 11C415.9 449.1 480 363.1 480 261.7 480 134.8 379.7 32 256 32z"/></svg>
</a>
<a href=https://mastodon.gamedev.place/@graeme class="mastodon icon" title=Mastodon><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 418 512" fill="currentcolor" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M433 179.11c0-97.2-63.71-125.7-63.71-125.7-62.52-28.7-228.56-28.4-290.48.0.0.0-63.72 28.5-63.72 125.7.0 115.7-6.6 259.4 105.63 289.1 40.51 10.7 75.32 13 103.33 11.4 50.81-2.8 79.32-18.1 79.32-18.1l-1.7-36.9s-36.31 11.4-77.12 10.1c-40.41-1.4-83-4.4-89.63-54a102.54 102.54.0 01-.9-13.9c85.63 20.9 158.65 9.1 178.75 6.7 56.12-6.7 105-41.3 111.23-72.9 9.8-49.8 9-121.5 9-121.5zm-75.12 125.2h-46.63v-114.2c0-49.7-64-51.6-64 6.9v62.5h-46.33V197c0-58.5-64-56.6-64-6.9v114.2H90.19c0-122.1-5.2-147.9 18.41-175 25.9-28.9 79.82-30.8 103.83 6.1l11.6 19.5 11.6-19.5c24.11-37.1 78.12-34.8 103.83-6.1 23.71 27.3 18.4 53 18.4 175z"/></svg>
</a>
</span>
</header>
<div class=post-header>
<h1 class=post-title><a href=/posts/unique-random-numbers/>Generating Unique Random Numbers</a></h1>
</div>
<div class=text-align-right>
<span class=date>September 27, 2024</span>
<br>
<ul class="tags post-tags">
[
<li><a href=/tags/maths/>maths</a>,</li>
<li><a href=/tags/rng/>rng</a></li>
]
</ul>
</div>
<div class=post>
<blockquote class=aside><p>This post has two things:</p>
<ol>
<li>Two somewhat obscure non-linear invertible operations that work on only part of a register, and</li>
<li>A fast stateless random permutation generator that uses them, and passes some statistical tests for RNGs you may have seen before</li>
</ol>
<p>The ideas are pretty simple so the hope is you can also get an intuition for how to think about the problem, which is the best thing you can get out of this post.</p>
<p>I got my intuition from these:</p>
<ul>
<li><a href=https://burtleburtle.net/bob/rand/talksmall.html>Bob Jenkins' talk</a> on writing hash functions,</li>
<li><a href=https://marc-b-reynolds.github.io/math/2017/10/13/IntegerBijections.html>Marc B Reynolds' post</a> on integer bijections (everything in this post is an integer bijection),</li>
<li>Brent Burley&rsquo;s <a href=https://jcgt.org/published/0009/04/01/>Practical Hash-based Owen Scrambling</a>, highly recommend this one if you like path tracing,</li>
<li><a href=https://andrew-helmer.github.io/permute/>Andrew Helmer&rsquo;s blog post</a> about Andrew Kensler&rsquo;s <code>permute</code> in this <a href=https://graphics.pixar.com/library/MultiJitteredSampling/paper.pdf>correlated multi-jitter paper</a>. Helmer&rsquo;s post is where I first saw this idea, I think.</li>
</ul>
</blockquote>
<p>Random numbers that don&rsquo;t repeat. Let me explain the basic idea first before I get into the weeds. We decide to generate unique random numbers in <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[0, N)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class=mopen>[</span><span class=mord>0</span><span class=mpunct>,</span><span class=mspace style=margin-right:.16666666666666666em></span><span class="mord mathdefault" style=margin-right:.10903em>N</span><span class=mclose>)</span></span></span></span>, here 8, by shuffling this list of numbers:
<span class=katex-display><span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>7</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,1,2,3,4,5,6,7)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class=mopen>(</span><span class=mord>0</span><span class=mpunct>,</span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mord>1</span><span class=mpunct>,</span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mord>2</span><span class=mpunct>,</span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mord>3</span><span class=mpunct>,</span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mord>4</span><span class=mpunct>,</span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mord>5</span><span class=mpunct>,</span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mord>6</span><span class=mpunct>,</span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mord>7</span><span class=mclose>)</span></span></span></span></span>
Adding the same number mod <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.68333em;vertical-align:0></span><span class="mord mathdefault" style=margin-right:.10903em>N</span></span></span></span> to every element gives us back a new list with the same elements in a different order,
<span class=katex-display><span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>7</mn><mo stretchy="false">)</mo><mo>+</mo><mn>3</mn><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mn>8</mn><mo>=</mo><mo stretchy="false">(</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,1,2,3,4,5,6,7) + 3 \mod 8 = (3,4,5,6,7,0,1,2)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class=mopen>(</span><span class=mord>0</span><span class=mpunct>,</span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mord>1</span><span class=mpunct>,</span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mord>2</span><span class=mpunct>,</span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mord>3</span><span class=mpunct>,</span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mord>4</span><span class=mpunct>,</span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mord>5</span><span class=mpunct>,</span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mord>6</span><span class=mpunct>,</span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mord>7</span><span class=mclose>)</span><span class=mspace style=margin-right:.2222222222222222em></span><span class=mbin>+</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:.64444em;vertical-align:0></span><span class=mord>3</span><span class="mspace allowbreak"></span><span class=mspace style=margin-right:1em></span></span><span class=base><span class=strut style=height:.69444em;vertical-align:0></span><span class=mord><span class=mord><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mord>8</span><span class=mspace style=margin-right:.2777777777777778em></span><span class=mrel>=</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class=mopen>(</span><span class=mord>3</span><span class=mpunct>,</span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mord>4</span><span class=mpunct>,</span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mord>5</span><span class=mpunct>,</span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mord>6</span><span class=mpunct>,</span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mord>7</span><span class=mpunct>,</span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mord>0</span><span class=mpunct>,</span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mord>1</span><span class=mpunct>,</span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mord>2</span><span class=mclose>)</span></span></span></span></span>
And so does multiplying by an odd number, mod <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.68333em;vertical-align:0></span><span class="mord mathdefault" style=margin-right:.10903em>N</span></span></span></span>,
<span class=katex-display><span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">)</mo><mo>∗</mo><mn>5</mn><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mn>8</mn><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(3,4,5,6,7,0,1,2) * 5 \mod 8 = (7,4,1,6,3,0,5,2)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class=mopen>(</span><span class=mord>3</span><span class=mpunct>,</span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mord>4</span><span class=mpunct>,</span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mord>5</span><span class=mpunct>,</span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mord>6</span><span class=mpunct>,</span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mord>7</span><span class=mpunct>,</span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mord>0</span><span class=mpunct>,</span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mord>1</span><span class=mpunct>,</span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mord>2</span><span class=mclose>)</span><span class=mspace style=margin-right:.2222222222222222em></span><span class=mbin>∗</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:.64444em;vertical-align:0></span><span class=mord>5</span><span class="mspace allowbreak"></span><span class=mspace style=margin-right:1em></span></span><span class=base><span class=strut style=height:.69444em;vertical-align:0></span><span class=mord><span class=mord><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mord>8</span><span class=mspace style=margin-right:.2777777777777778em></span><span class=mrel>=</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class=mopen>(</span><span class=mord>7</span><span class=mpunct>,</span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mord>4</span><span class=mpunct>,</span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mord>1</span><span class=mpunct>,</span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mord>6</span><span class=mpunct>,</span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mord>3</span><span class=mpunct>,</span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mord>0</span><span class=mpunct>,</span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mord>5</span><span class=mpunct>,</span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mord>2</span><span class=mclose>)</span></span></span></span></span>
And this now looks pretty shuffled. So, take in the original numbers one at a time, apply these and other bijections the same way on each number, and out the other end we get a pseudorandom permutation without using any memory. We never need to construct the initial list.</p>
<p>The operations we can use are any that can be undone (any shuffle can be re-sorted), so you hear people call them bijections and invertible functions interchangeably.</p>
<p>I got interested in this after looking at the low discrepancy sequence stuff, but I brushed off the connection in <a href=https://graemephi.github.io/posts/some-low-discrepancy-noise-functions/>my post</a> about it. With the tools there, its easy to generate numbers that don&rsquo;t repeat but hard to make them random. That is, you could feed truly random bits in and you&rsquo;d randomly select from a small set of random-looking sequences, which is not what we want. At the time, I didn&rsquo;t know much about this problem, just that what I was doing didn&rsquo;t work. This <a href=https://www.ea.com/seed/news/constant-time-stateless-shuffling>EA Seed post of Alan Wolfe and William Donnelly</a> that uses Feistel networks got me interested again. The thing that really got me is that quality/speed trade-off they mention: what does it take to max out the quality? How can you tell you&rsquo;ve reached it? Rather than answer these questions I made my own that always maxes the quality out.</p>
<p>To do that you need some organising principle. Mine is this: use all your bits.</p>
<p>What do I mean by this?</p>
<p>In the above example we have 8 numbers we can do an add with, from which we get 3 bits worth of permutations. The multiply is 2 bits, we lose a bit due to the odd constraint. We won&rsquo;t miss it for larger <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.68333em;vertical-align:0></span><span class="mord mathdefault" style=margin-right:.10903em>N</span></span></span></span>. To choose these randomly we need 5 random bits, for 32 possible multiply-adds. That&rsquo;s 32 different permutations we can get after one multiply-add, and, yes, any sequence of multiply-adds can be replaced by just one multiply-add, so out of these two operations we can&rsquo;t get more than 32 permutations. No matter how many random bits we have with which to choose different madds, we&rsquo;ll always end up with a sequence that can be reduced to a choice made with just 5 bits. Any more than that bits than that are wasted. We haven&rsquo;t used them.</p>
<p>There are <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn><mo stretchy="false">!</mo><mo>=</mo><mn>42320</mn></mrow><annotation encoding="application/x-tex">8! = 42320</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.69444em;vertical-align:0></span><span class=mord>8</span><span class=mclose>!</span><span class=mspace style=margin-right:.2777777777777778em></span><span class=mrel>=</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:.64444em;vertical-align:0></span><span class=mord>4</span><span class=mord>2</span><span class=mord>3</span><span class=mord>2</span><span class=mord>0</span></span></span></span> permutations of length 8.</p>
<h2 id=feistel-networks-entropy-and-so-on>Feistel networks, entropy, and so on</h2>
<p>What Feistel networks do is give you non-linear bijections, and you can turn the crank on them to get as many permutations as you want. How many turns of the crank you need can be found in this <a href=https://arxiv.org/abs/2106.06161>2022 Mitchell et al. paper </a> that adapts <a href=https://dl.acm.org/doi/10.1145/2063384.2063405>philox</a> to generate permutations. Philox is (mostly) a Feistel network. To get good statistics, turns out it&rsquo;s quite a lot: they want 24. This is the kind of round count you see in cryptography. What gives?</p>
<p>In a Feistel network, you split each number into two halves, one half that keys a round function and another half that gets permuted with a xor. This means to know how one number is scrambled by the round function, you only need to know half the bits in each step, and <em>this</em> means you get effectively half the entropy out of each round you could be getting (see this footnote if you are suspicious<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>). But this structure also makes it super easy to invert, which is very useful for encryption, right. For permutations of length 5, the function in the Mitchell paper will use 72 bits of entropy (and asks for some 700 bits that it just won&rsquo;t use). You need 7 bits to index all 120 permutations!!</p>
<p>This half-the-bits thing is important and is a good example of the kind of thinking you want to being doing when making these things, so, here. This is to illustrate something about bijections and the Feistel part isn&rsquo;t super important so I&rsquo;m not going to go in detail on that. Look:
<div style=display:flex;justify-content:center>
<img src=/posts/unique-random-numbers/feistel.png width=424 height=411 loading=lazy>
</div>
</p>
<p>This is a single round with the 8-bit input using a xor by some arbitrary function <code>f</code> as the round function. One Feistel round permutes only the blue box to produce the purple box; the orange box remains unchanged in the output and the low bits reappear, unchanged, as the new high bits. That&rsquo;s what I&rsquo;m talking about in the previous paragraph. But if you stare at this a while you may realise there are only 16 ways that purple box can end up, and the only thing <code>f</code> and <code>seed</code> can do is make the choice more or less predictable. This is the important part: a better choice of <code>f</code> can&rsquo;t give you more permutations than that. If you only do this one thing, then each round you get at most 16x new permutations, and they&rsquo;re the same new permutations regardless of <code>f</code>. A bad choice of <code>f</code> might fall short of all 16x, but ruling those out, the thing a better choice of <code>f</code> is giving you is a more unpredictable order with respect to <code>seed</code>.</p>
<p>And that might sound good but for most <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.68333em;vertical-align:0></span><span class="mord mathdefault" style=margin-right:.10903em>N</span></span></span></span> there are so many permutations we don&rsquo;t care about the order. If the order you see permutations in matters, that&rsquo;s bias. There are just too many permutations for it to be otherwise. I&rsquo;ll get back to this point later.</p>
<blockquote class=aside><p>I say a Feistel network will require too many bits, but it turns out to be really hard to use the minimal number of bits. Since I&rsquo;ve brought this up, check this out. How many bits will the Fisher-Yates shuffle use? It&rsquo;s the standard shuffle, and there used to be a little ecosystem of blog posts on how careless implementations could give bad statistics. My goal with this post is to match Fisher-Yates statistics-wise. (<a href=https://en.wikipedia.org/wiki/Fisher-Yates_shuffle>Code from Wikipedia</a>, why not):</p>
<pre tabindex=0><code class=language-terminal data-lang=terminal>-- To shuffle an array a of n elements (indices 0..n-1):
for i from 0 to n−2 do
     j ← random integer such that i ≤ j &lt; n
     exchange a[i] and a[j]
</code></pre><p>On the first iteration, we generate a number between <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.64444em;vertical-align:0></span><span class=mord>0</span></span></span></span> and <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.68333em;vertical-align:0></span><span class="mord mathdefault" style=margin-right:.10903em>N</span></span></span></span>, so <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">\log_2 N</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.93858em;vertical-align:-.24414em></span><span class=mop><span class=mop>lo<span style=margin-right:.01389em>g</span></span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.20696799999999996em><span style=top:-2.4558600000000004em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.24414em><span></span></span></span></span></span></span><span class=mspace style=margin-right:.16666666666666666em></span><span class="mord mathdefault" style=margin-right:.10903em>N</span></span></span></span> bits are needed to describe the number of possible outcomes of the first iteration. The second is between <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.64444em;vertical-align:0></span><span class=mord>1</span></span></span></span> and <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">N,</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.8777699999999999em;vertical-align:-.19444em></span><span class="mord mathdefault" style=margin-right:.10903em>N</span><span class=mpunct>,</span></span></span></span> that&rsquo;s <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mo stretchy="false">(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\log_2(N - 1)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class=mop><span class=mop>lo<span style=margin-right:.01389em>g</span></span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.20696799999999996em><span style=top:-2.4558600000000004em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.24414em><span></span></span></span></span></span></span><span class=mopen>(</span><span class="mord mathdefault" style=margin-right:.10903em>N</span><span class=mspace style=margin-right:.2222222222222222em></span><span class=mbin>−</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class=mord>1</span><span class=mclose>)</span></span></span></span> bits, and it&rsquo;s smaller because we have one less possible values to choose from, right. Continue like this, then by the end we&rsquo;ve used</p>
<p><span class=katex-display><span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>N</mi><mo>−</mo><mn>2</mn></mrow></munderover><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mo stretchy="false">(</mo><mi>N</mi><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>2</mn></mrow><mi>N</mi></munderover><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>i</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><munderover><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>2</mn></mrow><mi>N</mi></munderover><mi>i</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>N</mi><mo stretchy="false">!</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\sum_{i=0}^{N - 2} \log_2(N - i) &amp;= 
\sum_{i=2}^{N} \log_2 i \\
&amp;= \log_2\prod_{i=2}^N i \\
&amp;= \log_2 N!
\end{aligned}
</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:8.31201em;vertical-align:-3.9060050000000004em></span><span class=mord><span class=mtable><span class=col-align-r><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:4.406005em><span style=top:-6.406005em><span class=pstrut style=height:3.828336em></span><span class=mord><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:1.8283360000000004em><span style=top:-1.872331em;margin-left:0><span class=pstrut style=height:3.05em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style=top:-3.050005em><span class=pstrut style=height:3.05em></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style=top:-4.300005em;margin-left:0><span class=pstrut style=height:3.05em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style=margin-right:.10903em>N</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:1.277669em><span></span></span></span></span></span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mop><span class=mop>lo<span style=margin-right:.01389em>g</span></span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.20696799999999996em><span style=top:-2.4558600000000004em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.24414em><span></span></span></span></span></span></span><span class=mopen>(</span><span class="mord mathdefault" style=margin-right:.10903em>N</span><span class=mspace style=margin-right:.2222222222222222em></span><span class=mbin>−</span><span class=mspace style=margin-right:.2222222222222222em></span><span class="mord mathdefault">i</span><span class=mclose>)</span></span></span><span style=top:-3em><span class=pstrut style=height:3.828336em></span><span class=mord></span></span><span style=top:-.5823309999999999em><span class=pstrut style=height:3.828336em></span><span class=mord></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:3.9060050000000004em><span></span></span></span></span></span><span class=col-align-l><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:4.406005em><span style=top:-6.406005em><span class=pstrut style=height:3.828336em></span><span class=mord><span class=mord></span><span class=mspace style=margin-right:.2777777777777778em></span><span class=mrel>=</span><span class=mspace style=margin-right:.2777777777777778em></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:1.8283360000000002em><span style=top:-1.872331em;margin-left:0><span class=pstrut style=height:3.05em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">2</span></span></span></span><span style=top:-3.050005em><span class=pstrut style=height:3.05em></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style=top:-4.3000050000000005em;margin-left:0><span class=pstrut style=height:3.05em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style=margin-right:.10903em>N</span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:1.277669em><span></span></span></span></span></span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mop><span class=mop>lo<span style=margin-right:.01389em>g</span></span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.20696799999999996em><span style=top:-2.4558600000000004em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.24414em><span></span></span></span></span></span></span><span class=mspace style=margin-right:.16666666666666666em></span><span class="mord mathdefault">i</span></span></span><span style=top:-3em><span class=pstrut style=height:3.828336em></span><span class=mord><span class=mord></span><span class=mspace style=margin-right:.2777777777777778em></span><span class=mrel>=</span><span class=mspace style=margin-right:.2777777777777778em></span><span class=mop><span class=mop>lo<span style=margin-right:.01389em>g</span></span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.20696799999999996em><span style=top:-2.4558600000000004em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.24414em><span></span></span></span></span></span></span><span class=mspace style=margin-right:.16666666666666666em></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:1.8283360000000002em><span style=top:-1.872331em;margin-left:0><span class=pstrut style=height:3.05em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">2</span></span></span></span><span style=top:-3.050005em><span class=pstrut style=height:3.05em></span><span><span class="mop op-symbol large-op">∏</span></span></span><span style=top:-4.3000050000000005em;margin-left:0><span class=pstrut style=height:3.05em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style=margin-right:.10903em>N</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:1.277669em><span></span></span></span></span></span><span class=mspace style=margin-right:.16666666666666666em></span><span class="mord mathdefault">i</span></span></span><span style=top:-.5823309999999999em><span class=pstrut style=height:3.828336em></span><span class=mord><span class=mord></span><span class=mspace style=margin-right:.2777777777777778em></span><span class=mrel>=</span><span class=mspace style=margin-right:.2777777777777778em></span><span class=mop><span class=mop>lo<span style=margin-right:.01389em>g</span></span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.20696799999999996em><span style=top:-2.4558600000000004em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.24414em><span></span></span></span></span></span></span><span class=mspace style=margin-right:.16666666666666666em></span><span class="mord mathdefault" style=margin-right:.10903em>N</span><span class=mclose>!</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:3.9060050000000004em><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>bits of entropy. Exactly enough bits for the <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">N!</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.69444em;vertical-align:0></span><span class="mord mathdefault" style=margin-right:.10903em>N</span><span class=mclose>!</span></span></span></span> possible permutations: if you interpret the bits it draws as a number, then that number directly indexes into the big Lehmer-list in the sky of permutations of size <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.68333em;vertical-align:0></span><span class="mord mathdefault" style=margin-right:.10903em>N</span></span></span></span>. So, assuming we could draw a fractional number of bits from an RNG, this shuffle is optimal in the number of bits it will use. Something that took me a while to realise is that the exact same reasoning applies to figuring out the minimum number of bits it would take to encode the next value in a permutation, given those you&rsquo;ve already seen. :o</p>
<p>We won&rsquo;t get anywhere close to this lower bound, in both senses: for small <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.68333em;vertical-align:0></span><span class="mord mathdefault" style=margin-right:.10903em>N</span></span></span></span> I&rsquo;ll use too many bits, and for large <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.68333em;vertical-align:0></span><span class="mord mathdefault" style=margin-right:.10903em>N</span></span></span></span>, well, nobody ever will get close to using enough.</p>
<p>If all this talk of bits and entropy is lost on you: read David MacKay&rsquo;s <a href=https://www.inference.org.uk/itprnn/>Inference book</a>.</p>
</blockquote>
<p>Anyway, all that&rsquo;s why I went looking for other ways to map bits to bijections. My thinking is this: using cheaper non-linear bijections that operate on all the bits at once can produce more random lookin' permutations per unit time. The space of permutations that can be sampled <em>at all</em> can expand up to twice as quickly by having no half-width bottlenecks.</p>
<h2 id=two-invertible-operations>Two invertible operations</h2>
<h4 id=1>1</h4>
<p>Everyone into this junk knows odd multiplies are invertible and even multiplies aren&rsquo;t. That&rsquo;s wrong: even multiplies are perfectly invertible. It&rsquo;s only after truncating the bits that don&rsquo;t fit in the register that invertibility is lost. They don&rsquo;t have invertibility <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>mod </mtext><msup><mn>2</mn><mi>b</mi></msup></mrow><annotation encoding="application/x-tex">\text{mod } 2^b</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.849108em;vertical-align:0></span><span class="mord text"><span class=mord>mod </span></span><span class=mord><span class=mord>2</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.849108em><span style=top:-3.063em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span></span></span></span></span></span></span>, but here, <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.69444em;vertical-align:0></span><span class="mord mathdefault">b</span></span></span></span> is probably small, and there is still plenty of register left over. So, don&rsquo;t truncate: shift.</p>
<pre tabindex=0><code class=language-terminal data-lang=terminal>a : value to permute
k : random bits, or constant, whatever

m = (1 &lt;&lt; bitwidth(a)) - 1                 (mask for getting a back into range)

k_low_bits = (k &amp; -k) - 1                  (turn trailing zeros into a mask)
k += ((k &amp; m) == 0)                        (fix up if k is 0)

ak = a * k                                 (multiply)
a = ak + ((ak &gt;&gt; bits) &amp; k_low_bits)       (rotate)
</code></pre><p>Spelled out: even multiplies can be split into two operations, an odd multiply and a left shift; the shift amount is the number of trailing zeros. To restore invertibility we could shift back to undo that shift, but this lands it back at an odd multiply so we&rsquo;re still down a bit. Instead, do a rotate, by shifting the bits otherwise masked out into the low bits that were just zeroed out by the multiply.</p>
<p>This is fine as is for small bit-widths, but if <code>bitwidth(a)</code> is greater than the half the register width then <code>k</code> can have so many trailing zeros that the multiply runs out of register. For <code>bitwidth(a)</code> up at like 30 then it can only handle at most 2 trailing zeros. We don&rsquo;t care about the missing bit that much in that case, so just detect when there are too many trailing zeros and turn it into a multiply by one:</p>
<pre tabindex=0><code class=language-terminal data-lang=terminal>km = m &amp; (~0u &gt;&gt; bits)                      (note, km == m when bits &lt; regsiter width / 2)
k += ((k &amp; km) == 0)                        (new fix up)
</code></pre><p>This is getting a bit complicated. The up shot is we get an almost full-bit multiply and a non-linearity out of it. &lsquo;Almost&rsquo; because we still can&rsquo;t multiply by zero. To underscore the point a bit, the shift amount is constant with respect to <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.68333em;vertical-align:0></span><span class="mord mathdefault" style=margin-right:.10903em>N</span></span></span></span> but the effective rotation amount depends on <code>k</code>.</p>
<p>If you choose <code>k</code> randomly then the random rotates we get follow a geometric distribution: <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">1/2</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class=mord>1</span><span class=mord>/</span><span class=mord>2</span></span></span></span> chance the first bit is zero, <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">1/4</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class=mord>1</span><span class=mord>/</span><span class=mord>4</span></span></span></span> the first and second bit are both zero, &mldr; So it&rsquo;s usually 0, 1 or 2. That works well here because it means it just works for all <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.68333em;vertical-align:0></span><span class="mord mathdefault" style=margin-right:.10903em>N</span></span></span></span>&ndash;for small <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.68333em;vertical-align:0></span><span class="mord mathdefault" style=margin-right:.10903em>N</span></span></span></span>, if we only have, say, 3 bits then we can only do rotates of 1 or 2 bits, so if we have a lot of larger rotates we aren&rsquo;t getting the non-linearities we want. Likewise for large <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.68333em;vertical-align:0></span><span class="mord mathdefault" style=margin-right:.10903em>N</span></span></span></span>, where we need to avoid shifting away bits at the opposite end, we don&rsquo;t have to worry about that happening often either. But for other <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.68333em;vertical-align:0></span><span class="mord mathdefault" style=margin-right:.10903em>N</span></span></span></span> we&rsquo;d really like to get bits moving in different ways. So there&rsquo;s room for improvement, maybe.</p>
<h4 id=2>2</h4>
<p>The second invertible operation I&rsquo;d like to point out is actually a repeat from <a href=https://graemephi.github.io/posts/some-low-discrepancy-noise-functions/>last time</a>, where it appeared in the Laine-Karras scramble (and I got it from the <a href=https://jcgt.org/published/0009/04/01/>Brent Burley</a> paper originally). But this time I got to it by thinking: the above is using the low zero bits of <code>k</code> as the shift amount. Can we swap our operands around and use the low zero bits of <code>a</code> as the shift amount? Then we&rsquo;d get a varying rotate per <code>a</code>. But I couldn&rsquo;t figure out a way to use that idea that was actually invertible. However in a moment of zen I realized the following is invertible:</p>
<pre tabindex=0><code class=language-terminal data-lang=terminal>a ^= (a * k) &lt;&lt; 1
</code></pre><p>Which is exactly equivalent to the multiplication by even constants in the nested uniform scramble.</p>
<p>This is pretty interesting in that, if you look at it like a Feistel function, then rather than splitting up the permutation into equal sized classes indexed by half the bits, it splits it into classes indexed by the number of trailing zeros in <code>a</code>. Not only are the classes shuffled independently, so values in one class stay in that class, each class is a different size. Within each, the permute is driven by the multiply. (Sorry if all this is a bit abstract all of a sudden).</p>
<p>But in light of what I said before about Feistel networks I will use it like this, because the bits in <code>k</code> are valuable:</p>
<pre tabindex=0><code class=language-terminal data-lang=terminal>a ^= ((a * k) &lt;&lt; 1) ^ k
</code></pre><p>So that&rsquo;s two bijections. One is a little complicated code-wise but is really simple conceptually; an odd multiply followed by a rotate. It&rsquo;s easy to see why it&rsquo;s invertible. One is simple code-wise and is complicated conceptually; I don&rsquo;t know what to call it. It&rsquo;s a bit more subtle I think.</p>
<h2 id=permute>permute</h2>
<p>To use these, I need to define the problem. We want to <strong>randomly sample permutations</strong>, uniformly and independently. For small <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.68333em;vertical-align:0></span><span class="mord mathdefault" style=margin-right:.10903em>N</span></span></span></span>, this means sometimes sampling 0, 1, 2, 3, 4&mldr; as a random permutation. So, that&rsquo;s a stateless function like this, where <code>seed</code> enumerates permutations in a pseudorandom order.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>uint32_t</span> <span style=color:#a6e22e>permute</span>(<span style=color:#66d9ef>uint32_t</span> i, <span style=color:#66d9ef>uint32_t</span> N, <span style=color:#66d9ef>uint32_t</span> seed);

<span style=color:#75715e>// Usage:
</span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>uint32_t</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> N; i<span style=color:#f92672>++</span>) {
	<span style=color:#66d9ef>uint32_t</span> index <span style=color:#f92672>=</span> permute(i, N, seed);
	
	<span style=color:#75715e>// ... use index 
</span><span style=color:#75715e></span>}
</code></pre></div><p>Secondary goal is that it should just work. No need to seed it well. Cycle walking for non powers of two<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>.</p>
<p>The idea is that generating pseudorandom bits is expensive, so do it once at the start, and shift out the generated bits from a register as a source of entropy. Then use each bit of entropy at least once. I found the two bijections above weren&rsquo;t enough on their own for good avalanche so I gray code between each use of entropy bits:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>uint32_t</span> <span style=color:#a6e22e>hash32</span>(<span style=color:#66d9ef>uint32_t</span> x) {
    x <span style=color:#f92672>^=</span> x <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>16</span>;
    x <span style=color:#f92672>*=</span> <span style=color:#ae81ff>0x21f0aaad</span>;
    x <span style=color:#f92672>^=</span> x <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>15</span>;
    x <span style=color:#f92672>*=</span> <span style=color:#ae81ff>0xd35a2d97</span>;
    x <span style=color:#f92672>^=</span> x <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>15</span>;
    <span style=color:#66d9ef>return</span> x;
}

<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>uint32_t</span> <span style=color:#a6e22e>log2_floor</span>(<span style=color:#66d9ef>uint32_t</span> a) {
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>31u</span> <span style=color:#f92672>-</span> _lzcnt_u32(a);
}

<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>uint32_t</span> <span style=color:#a6e22e>log2_ceil</span>(<span style=color:#66d9ef>uint32_t</span> a) {
    <span style=color:#66d9ef>return</span> log2_floor(a <span style=color:#f92672>-</span> <span style=color:#ae81ff>1u</span>) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1u</span>;
}

<span style=color:#66d9ef>uint32_t</span> <span style=color:#a6e22e>permute</span>(<span style=color:#66d9ef>uint32_t</span> i, <span style=color:#66d9ef>uint32_t</span> n, <span style=color:#66d9ef>uint32_t</span> seed) {
    <span style=color:#66d9ef>uint32_t</span> bits <span style=color:#f92672>=</span> log2_ceil(n);
    <span style=color:#66d9ef>uint32_t</span> mask <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1u</span> <span style=color:#f92672>&lt;&lt;</span> bits) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1u</span>;
    <span style=color:#66d9ef>uint32_t</span> multiplier_mask <span style=color:#f92672>=</span> mask <span style=color:#f92672>&amp;</span> (<span style=color:#f92672>~</span><span style=color:#ae81ff>0u</span> <span style=color:#f92672>&gt;&gt;</span> bits); 
    <span style=color:#66d9ef>uint32_t</span> index_seed <span style=color:#f92672>=</span> (i <span style=color:#f92672>&gt;&gt;</span> bits) <span style=color:#f92672>^</span> n;
    
    <span style=color:#66d9ef>uint32_t</span> state0 <span style=color:#f92672>=</span> seed <span style=color:#f92672>+</span> index_seed; 
    <span style=color:#66d9ef>uint32_t</span> state1 <span style=color:#f92672>=</span> hash32(index_seed <span style=color:#f92672>-</span> seed);

    <span style=color:#66d9ef>do</span> {        
        <span style=color:#66d9ef>uint32_t</span> state <span style=color:#f92672>=</span> state0;
        <span style=color:#66d9ef>uint32_t</span> rounds <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;

        <span style=color:#66d9ef>while</span> (rounds<span style=color:#f92672>--</span>) {
            <span style=color:#66d9ef>uint32_t</span> p <span style=color:#f92672>=</span> state;

            <span style=color:#66d9ef>do</span> {
                <span style=color:#66d9ef>uint32_t</span> q <span style=color:#f92672>=</span> p;
                p <span style=color:#f92672>&gt;&gt;=</span> bits;
                <span style=color:#66d9ef>uint32_t</span> r <span style=color:#f92672>=</span> p <span style=color:#f92672>^</span> state;
                p <span style=color:#f92672>&gt;&gt;=</span> bits;
                <span style=color:#66d9ef>uint32_t</span> s <span style=color:#f92672>=</span> p <span style=color:#f92672>^</span> state;
                p <span style=color:#f92672>&gt;&gt;=</span> bits;

                q <span style=color:#f92672>&amp;=</span> <span style=color:#f92672>~</span><span style=color:#ae81ff>1u</span>;
                q <span style=color:#f92672>+=</span> ((q <span style=color:#f92672>&amp;</span> multiplier_mask) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0u</span>) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span>;
                <span style=color:#66d9ef>uint32_t</span> q_lb <span style=color:#f92672>=</span> (q <span style=color:#f92672>&amp;</span> (<span style=color:#ae81ff>0u</span> <span style=color:#f92672>-</span> q)) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1u</span>;

                i <span style=color:#f92672>^=</span> ((i <span style=color:#f92672>*</span> p) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>^</span> p;
                i <span style=color:#f92672>^=</span> (i <span style=color:#f92672>&amp;</span> mask) <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>1</span>;
                <span style=color:#66d9ef>uint32_t</span> iqr <span style=color:#f92672>=</span> (i <span style=color:#f92672>*</span> q) <span style=color:#f92672>+</span> r; 
                i <span style=color:#f92672>=</span> iqr <span style=color:#f92672>+</span> ((i <span style=color:#f92672>^</span> (iqr <span style=color:#f92672>&gt;&gt;</span> bits)) <span style=color:#f92672>&amp;</span> q_lb);
                i <span style=color:#f92672>^=</span> (i <span style=color:#f92672>&amp;</span> mask) <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>3</span>;
                i <span style=color:#f92672>^=</span> ((i <span style=color:#f92672>*</span> s) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>^</span> s;
                i <span style=color:#f92672>^=</span> (i <span style=color:#f92672>&amp;</span> mask) <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>7</span>;
            } <span style=color:#66d9ef>while</span> (p);

            state <span style=color:#f92672>=</span> state1;
        }
        
        i <span style=color:#f92672>&amp;=</span> mask;
    } <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&gt;=</span> n);
    
    <span style=color:#66d9ef>return</span> i;
}
</code></pre></div><p>I kept it all within 32-bits to make it easier to analyze. It doesn&rsquo;t work for <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>&gt;</mo><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">N &gt; 2^{31}</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.72243em;vertical-align:-.0391em></span><span class="mord mathdefault" style=margin-right:.10903em>N</span><span class=mspace style=margin-right:.2777777777777778em></span><span class=mrel>></span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:.8141079999999999em;vertical-align:0></span><span class=mord><span class=mord>2</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.8141079999999999em><span style=top:-3.063em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>. If you want that, go to 64-bits. Replace the hash and add</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>i <span style=color:#f92672>^=</span> (i <span style=color:#f92672>&amp;</span> mask) <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>15</span>;
</code></pre></div><p>somewhere. One benefit of having no constants is it&rsquo;s clear how to extend this thing to higher bit counts.</p>
<h3 id=fiddly-detail>Fiddly detail</h3>
<blockquote class=aside><p>The high bits in the index would otherwise go to waste so I use them as more seed bits, so each seed really defines a sequence of permutations per <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.68333em;vertical-align:0></span><span class="mord mathdefault" style=margin-right:.10903em>N</span></span></span></span>, rather than just one permutation per <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.68333em;vertical-align:0></span><span class="mord mathdefault" style=margin-right:.10903em>N</span></span></span></span>.</p>
<p>The <code>log2_ceil</code> is a little exotic in a non-systems language context but it is pretty much free here with <code>lzcnt</code>, you probably want to pass it in precomputed if it or an equivalent instruction is not available, the alternatives really dent the speed of this thing. <a href=https://stackoverflow.com/a/51351885>It&rsquo;s from Travis Downs</a>.</p>
<p>The hash function is one of those <a href=https://nullprogram.com/blog/2018/07/31/>prospecting for hash functions</a> hashes. The way I use it, you can see you could also pull it out precomputed once for the whole permutation, if you really wanted to.</p>
<p>As well as the add, I sneak in a xor of the original bits in middle of the multiply-rotate. Philox-y. And there&rsquo;s always at least 1 bit of rotation.</p>
<p>I don&rsquo;t like the <code>while (p)</code>, I&rsquo;d rather use a fixed number of iterations derived from <code>n</code>. As it is, larger <code>n</code> shift bits out faster and stop earlier. But it will also stop early if the state becomes 0. It works better statistics-for-time this way, which I don&rsquo;t really understand.</p>
</blockquote>
<h3 id=justifications>Justifications</h3>
<p>For <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.68333em;vertical-align:0></span><span class="mord mathdefault" style=margin-right:.10903em>N</span></span></span></span> larger than 12, 32 bits is not enough seeds to index every permutation, so it&rsquo;s fine to fall short of hitting every permutation, so long as the sampling is<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup> unbiased.</p>
<p>To be unbiased we need this: it doesn&rsquo;t matter how you seed this thing. Consecutive seeds must produce permutations that are uncorrelated. It doesn&rsquo;t take long before the space of <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">N!</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.69444em;vertical-align:0></span><span class="mord mathdefault" style=margin-right:.10903em>N</span><span class=mclose>!</span></span></span></span> permutations it&rsquo;s supposed to be sampling from is so vast that all <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.8141079999999999em;vertical-align:0></span><span class=mord><span class=mord>2</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.8141079999999999em><span style=top:-3.063em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> permutations are a vanishingly small subset. So, if nearby seeds are correlated, we already know we are sampling from a biased sample of all permutations. That&rsquo;s why I use the seed directly in the first round: we could hash it, and this will probably give us better <code>(state0, state1)</code> pairs to use (there are <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>64</mn></msup></mrow><annotation encoding="application/x-tex">2^{64}</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.8141079999999999em;vertical-align:0></span><span class=mord><span class=mord>2</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.8141079999999999em><span style=top:-3.063em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span> such pairs and we&rsquo;ll use <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.8141079999999999em;vertical-align:0></span><span class=mord><span class=mord>2</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.8141079999999999em><span style=top:-3.063em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> of them), but there is no simple way to avoid having many mostly-zero states in one side of the pair; all we can control is what order we get them in.</p>
<p>For that reason, I don&rsquo;t think we can get away with using only 32 bits of state, even though we&rsquo;ll only ever map to 32 bits worth of permutations. If we hash, we can use an invertible hash to guarantee each seed maps to unique hash bits. But this means we just shuffled the low-entropy seeds around. Or we use a non-invertible hash, and we know for sure some seeds map to the same permutation&ndash;can&rsquo;t be having it. Even if we pack this thing to the gills with intimidating constants, a low entropy seed will mean we land on a permutation near (in some sense) to the default permutation selected by the constants.</p>
<p>Expanding the seed an extra 32 bits solves all this.</p>
<p>To get an idea for why we really cannot have any correlations period, think about lexicographically sorting all the permutations and looking for correlations between nearby seeds. If <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>=</mo><mn>500</mn></mrow><annotation encoding="application/x-tex">N = 500</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.68333em;vertical-align:0></span><span class="mord mathdefault" style=margin-right:.10903em>N</span><span class=mspace style=margin-right:.2777777777777778em></span><span class=mrel>=</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:.64444em;vertical-align:0></span><span class=mord>5</span><span class=mord>0</span><span class=mord>0</span></span></span></span> then for the first 10 values we have <span class=katex-display><span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mn>500</mn><mn>10</mn></mfrac><mo fence="true">)</mo></mrow><mo>&gt;</mo><msup><mn>2</mn><mn>67</mn></msup></mrow><annotation encoding="application/x-tex">{500 \choose 10} &gt; 2^{67}</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:2.40003em;vertical-align:-.95003em></span><span class=mord><span class=mord><span class="mopen delimcenter" style=top:0><span class="delimsizing size3">(</span></span><span class=mfrac><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:1.32144em><span style=top:-2.314em><span class=pstrut style=height:3em></span><span class=mord><span class=mord>1</span><span class=mord>0</span></span></span><span style=top:-3.677em><span class=pstrut style=height:3em></span><span class=mord><span class=mord>5</span><span class=mord>0</span><span class=mord>0</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.686em><span></span></span></span></span></span><span class="mclose delimcenter" style=top:0><span class="delimsizing size3">)</span></span></span></span><span class=mspace style=margin-right:.2777777777777778em></span><span class=mrel>></span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:.8641079999999999em;vertical-align:0></span><span class=mord><span class=mord>2</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.8641079999999999em><span style=top:-3.113em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span></span></span> possible permutation-heads, so by the 11th value we expect the sorted permutations to be completely uncorrelated again.</p>
<p>The restriction to 32-bit integers is somewhat artificial but it also enabled reasoning like the above that I&rsquo;m not sure I&rsquo;d have got to without it.</p>
<h2 id=testing-these-things>Testing these things</h2>
<p>A quick test that will fail most ideas you come up with is to generate permutations of size 8, each value is 3 bits so you only need 24 bits to represent an entire permutation. Generate a bunch, pack each into an int and compare the number of unique ints you get to unique numbers from a PRNG in <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>8</mn><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[0, 8!)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class=mopen>[</span><span class=mord>0</span><span class=mpunct>,</span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mord>8</span><span class=mclose>!</span><span class=mclose>)</span></span></span></span>. Or math it out, but we&rsquo;re all friends here. This fails <code>permute</code> when using a single round.</p>
<p>To get an idea for the behaviour with larger <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.68333em;vertical-align:0></span><span class="mord mathdefault" style=margin-right:.10903em>N</span></span></span></span> you can make a <a href=https://bost.ocks.org/mike/shuffle/compare.html>matrix diagram</a> that visualises how often a each input index gets mapped to each output index. This works but I found you could look good here while still being biased (this is true of avalanche as well). Instead, try this: look for correlations between adjacent indices. So, instead of counting <code>(i, permute(i))</code> pairs, count <code>(permute(i), permute(i + 1))</code> pairs. Somewhat interestingly, since these are always different, the pairs this gives you form a particular kind of permutation called a <a href=https://en.wikipedia.org/wiki/Derangement>derangement</a>. With that said, here&rsquo;s <code>permute</code> with only 1 round, <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>=</mo><mn>1024</mn></mrow><annotation encoding="application/x-tex">N=1024</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.68333em;vertical-align:0></span><span class="mord mathdefault" style=margin-right:.10903em>N</span><span class=mspace style=margin-right:.2777777777777778em></span><span class=mrel>=</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:.64444em;vertical-align:0></span><span class=mord>1</span><span class=mord>0</span><span class=mord>2</span><span class=mord>4</span></span></span></span> and <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16</mn><mi>N</mi></mrow><annotation encoding="application/x-tex">16N</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.68333em;vertical-align:0></span><span class=mord>1</span><span class=mord>6</span><span class="mord mathdefault" style=margin-right:.10903em>N</span></span></span></span> consecutive seeds near 0:
<div style=display:flex;justify-content:center>
<img src=/posts/unique-random-numbers/urn_seq_1.png width=1024 height=1024 loading=lazy>
</div>
<blockquote class=aside>Scaled down by <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>⋅</mo><mn>16</mn><mi>N</mi><mo>⋅</mo><mfrac><mn>1</mn><mrow><mo stretchy="false">(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">2\cdot16N\cdot\frac{1}{(N-1)}</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.64444em;vertical-align:0></span><span class=mord>2</span><span class=mspace style=margin-right:.2222222222222222em></span><span class=mbin>⋅</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:.68333em;vertical-align:0></span><span class=mord>1</span><span class=mord>6</span><span class="mord mathdefault" style=margin-right:.10903em>N</span><span class=mspace style=margin-right:.2222222222222222em></span><span class=mbin>⋅</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:1.365108em;vertical-align:-.52em></span><span class=mord><span class="mopen nulldelimiter"></span><span class=mfrac><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:.845108em><span style=top:-2.655em><span class=pstrut style=height:3em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style=margin-right:.10903em>N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span><span style=top:-3.23em><span class=pstrut style=height:3em></span><span class=frac-line style=border-bottom-width:.04em></span></span><span style=top:-3.394em><span class=pstrut style=height:3em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.52em><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> which puts the expected average at <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.5</mn></mrow><annotation encoding="application/x-tex">0.5</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.64444em;vertical-align:0></span><span class=mord>0</span><span class=mord>.</span><span class=mord>5</span></span></span></span>. And fed through the <code>BrGB</code> colour map from matplotlib which is white in the middle. It&rsquo;s much more clear what&rsquo;s going on compared to grayscale.</blockquote>
</p>
<p>The zeros along the diagonal are expected, as it&rsquo;s a derangement. But it&rsquo;s not quite there yet, note that near the diagonal it is slightly darker and undersampled.
Here&rsquo;s two rounds:
<div style=display:flex;justify-content:center>
<img src=/posts/unique-random-numbers/urn_seq_2.png width=1024 height=1024 loading=lazy>
</div>
</p>
<p>👍. These are all the seeds around zero&ndash;all ones, all zeros, 31 ones, 31 zeros, that kind of junk.</p>
<p>The last test I like is for small <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.68333em;vertical-align:0></span><span class="mord mathdefault" style=margin-right:.10903em>N</span></span></span></span>, counting repeat permutations. Similar to the first test but more involved to actually implement. This is an interesting test because when we randomly sample permutations of length <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>13</mn></mrow><annotation encoding="application/x-tex">13</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.64444em;vertical-align:0></span><span class=mord>1</span><span class=mord>3</span></span></span></span>, there are more than <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.8141079999999999em;vertical-align:0></span><span class=mord><span class=mord>2</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.8141079999999999em><span style=top:-3.063em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> permutations to sample but the number of samples before we expect to see a repeat is far less than <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.8141079999999999em;vertical-align:0></span><span class=mord><span class=mord>2</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.8141079999999999em><span style=top:-3.063em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>. Knuth in TAOCP somewhere has an approximate formula for this
<span class=katex-display><span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo><mo>∼</mo><mn>1</mn><mo>+</mo><msqrt><mfrac><mrow><mi>π</mi><mi>N</mi><mo stretchy="false">!</mo></mrow><mn>2</mn></mfrac></msqrt><mo>+</mo><mtext> </mtext><mo>…</mo></mrow><annotation encoding="application/x-tex">Q(N!) \sim 1 + \sqrt{\frac{\pi N!}{2}} +\space\dots</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class="mord mathdefault">Q</span><span class=mopen>(</span><span class="mord mathdefault" style=margin-right:.10903em>N</span><span class=mclose>!</span><span class=mclose>)</span><span class=mspace style=margin-right:.2777777777777778em></span><span class=mrel>∼</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:.72777em;vertical-align:-.08333em></span><span class=mord>1</span><span class=mspace style=margin-right:.2222222222222222em></span><span class=mbin>+</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:2.44em;vertical-align:-.7634050000000001em></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:1.6765949999999998em><span class=svg-align style=top:-4.4em><span class=pstrut style=height:4.4em></span><span class=mord style=padding-left:1em><span class=mord><span class="mopen nulldelimiter"></span><span class=mfrac><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:1.37144em><span style=top:-2.314em><span class=pstrut style=height:3em></span><span class=mord><span class=mord>2</span></span></span><span style=top:-3.23em><span class=pstrut style=height:3em></span><span class=frac-line style=border-bottom-width:.04em></span></span><span style=top:-3.677em><span class=pstrut style=height:3em></span><span class=mord><span class="mord mathdefault" style=margin-right:.03588em>π</span><span class="mord mathdefault" style=margin-right:.10903em>N</span><span class=mclose>!</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.686em><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style=top:-3.6365950000000002em><span class=pstrut style=height:4.4em></span><span class=hide-tail style=min-width:1.02em;height:2.48em><svg width="400em" height="2.48em" viewBox="0 0 4e5 2592" preserveAspectRatio="xMinYMin slice"><path d="M424 2478c-1.3-.7-38.5-172-111.5-514S202.7 1450.7 202 1450c0-2-10.7 14.3-32 49-4.7 7.3-9.8 15.7-15.5 25s-9.8 16-12.5 20-5 7-5 7c-4-3.3-8.3-7.7-13-13s-13-13-13-13 76-122 76-122 77-121 77-121 209 968 209 968c0-2 84.7-361.7 254-1079S981.7 93.3 983 90c4-6.7 10-10 18-10H4e5v40H1014.6S927.3 498.7 742 1286c-185.3 787.3-279.3 1182.3-282 1185-2 6-10 9-24 9-8 0-12-.7-12-2zM1001 80h4e5v40h-4e5z"/></svg></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.7634050000000001em><span></span></span></span></span></span><span class=mspace style=margin-right:.2222222222222222em></span><span class=mbin>+</span><span class=mspace style=margin-right:.2222222222222222em></span><span class=mspace> </span></span><span class=base><span class=strut style=height:.12em;vertical-align:0></span><span class=minner>…</span></span></span></span></span>
which is also <a href=https://en.wikipedia.org/wiki/Birthday_problem#Average_number_of_people_to_get_at_least_one_shared_birthday>lurking on the Wikipedia article on the birthday problem</a>. From this you get that only after <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>&gt;</mo><mn>21</mn></mrow><annotation encoding="application/x-tex">N &gt; 21</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.72243em;vertical-align:-.0391em></span><span class="mord mathdefault" style=margin-right:.10903em>N</span><span class=mspace style=margin-right:.2777777777777778em></span><span class=mrel>></span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:.64444em;vertical-align:0></span><span class=mord>2</span><span class=mord>1</span></span></span></span> or <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>22</mn></mrow><annotation encoding="application/x-tex">22</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.64444em;vertical-align:0></span><span class=mord>2</span><span class=mord>2</span></span></span></span> or so is it reasonable to map each seed to a unique permutation, as <span class=katex-display><span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><mn>21</mn><mo stretchy="false">!</mo><mo stretchy="false">)</mo><mo>≈</mo><msup><mn>2</mn><mn>33</mn></msup></mrow><annotation encoding="application/x-tex">Q(21!) \approx 2^{33}</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class="mord mathdefault">Q</span><span class=mopen>(</span><span class=mord>2</span><span class=mord>1</span><span class=mclose>!</span><span class=mclose>)</span><span class=mspace style=margin-right:.2777777777777778em></span><span class=mrel>≈</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:.8641079999999999em;vertical-align:0></span><span class=mord><span class=mord>2</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.8641079999999999em><span style=top:-3.113em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span></span> but <span class=katex-display><span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><mn>20</mn><mo stretchy="false">!</mo><mo stretchy="false">)</mo><mo>≈</mo><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">Q(20!)\approx 2^{31}</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class="mord mathdefault">Q</span><span class=mopen>(</span><span class=mord>2</span><span class=mord>0</span><span class=mclose>!</span><span class=mclose>)</span><span class=mspace style=margin-right:.2777777777777778em></span><span class=mrel>≈</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:.8641079999999999em;vertical-align:0></span><span class=mord><span class=mord>2</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.8641079999999999em><span style=top:-3.113em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>Between 13 and 20, in order to look statistically right, we need to be producing repeats&ndash;even though there are more permutations than seeds!!</p>
<p>This test is the hardest I&rsquo;ve found to pass: an older function I had was a real slow thing with some Feistel rounds that looked otherwise good, and this test failed it at <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>=</mo><mn>19</mn></mrow><annotation encoding="application/x-tex">N = 19</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.68333em;vertical-align:0></span><span class="mord mathdefault" style=margin-right:.10903em>N</span><span class=mspace style=margin-right:.2777777777777778em></span><span class=mrel>=</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:.64444em;vertical-align:0></span><span class=mord>1</span><span class=mord>9</span></span></span></span>. Unfailing it is how I got to the multiply-rotate. At the time I was looking at gaps, but <a href=https://www.pcg-random.org/posts/birthday-test.html>M.E. O&rsquo;Neill points out you can also count repeats</a> and tells you how many samples to take and how to compute p-values so let&rsquo;s just use that. I&rsquo;m going to dump a table on you now. Each row looks at consecutive seeds starting at <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.64444em;vertical-align:0></span><span class=mord>0</span></span></span></span>:</p>
<table>
<thead>
<tr>
<th>N</th>
<th>samples</th>
<th>dupes</th>
<th>expected</th>
<th>unique_dupes</th>
<th>p</th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
<td>16</td>
<td>10</td>
<td>10.32</td>
<td>4</td>
<td>0.54</td>
</tr>
<tr>
<td>4</td>
<td>31</td>
<td>14</td>
<td>13.42</td>
<td>8</td>
<td>0.63</td>
</tr>
<tr>
<td>5</td>
<td>70</td>
<td>19</td>
<td>16.80</td>
<td>16</td>
<td>0.75</td>
</tr>
<tr>
<td>6</td>
<td>170</td>
<td>21</td>
<td>18.49</td>
<td>18</td>
<td>0.76</td>
</tr>
<tr>
<td>7</td>
<td>449</td>
<td>18</td>
<td>19.38</td>
<td>18</td>
<td>0.44</td>
</tr>
<tr>
<td>8</td>
<td>1270</td>
<td>16</td>
<td>19.78</td>
<td>16</td>
<td>0.24</td>
</tr>
<tr>
<td>9</td>
<td>3810</td>
<td>13</td>
<td>19.93</td>
<td>13</td>
<td>0.07</td>
</tr>
<tr>
<td>10</td>
<td>12048</td>
<td>14</td>
<td>19.98</td>
<td>14</td>
<td>0.11</td>
</tr>
<tr>
<td>11</td>
<td>39959</td>
<td>19</td>
<td>19.99</td>
<td>19</td>
<td>0.47</td>
</tr>
<tr>
<td>12</td>
<td>138420</td>
<td>19</td>
<td>20.00</td>
<td>19</td>
<td>0.47</td>
</tr>
<tr>
<td>13</td>
<td>499080</td>
<td>20</td>
<td>20.00</td>
<td>20</td>
<td>0.56</td>
</tr>
<tr>
<td>14</td>
<td>1867387</td>
<td>16</td>
<td>20.00</td>
<td>16</td>
<td>0.22</td>
</tr>
<tr>
<td>15</td>
<td>7232357</td>
<td>19</td>
<td>20.00</td>
<td>19</td>
<td>0.47</td>
</tr>
<tr>
<td>16</td>
<td>28929425</td>
<td>19</td>
<td>20.00</td>
<td>19</td>
<td>0.47</td>
</tr>
<tr>
<td>17</td>
<td>119279073</td>
<td>12</td>
<td>20.00</td>
<td>12</td>
<td>0.04</td>
</tr>
<tr>
<td>18</td>
<td>506058246</td>
<td>20</td>
<td>20.00</td>
<td>20</td>
<td>0.56</td>
</tr>
<tr>
<td>19</td>
<td>2205856754</td>
<td>26</td>
<td>20.00</td>
<td>26</td>
<td>0.92</td>
</tr>
<tr>
<td>20</td>
<td>4294967295</td>
<td>5</td>
<td>3.79</td>
<td>5</td>
<td>0.82</td>
</tr>
<tr>
<td>21</td>
<td>4294967295</td>
<td>1</td>
<td>0.18</td>
<td>1</td>
<td>0.99</td>
</tr>
<tr>
<td>22</td>
<td>4294967295</td>
<td>0</td>
<td>0.01</td>
<td>0</td>
<td>0.99</td>
</tr>
</tbody>
</table>
<p>Yeh: looks random. The p-value breaks down a bit towards the end there because we are taking so few (!!) samples, but whatever. The <code>unique_dupes</code> column is just a sanity check that we aren&rsquo;t getting the same repeated permutation.</p>
<p>Counting repeats from all <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.8141079999999999em;vertical-align:0></span><span class=mord><span class=mord>2</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.8141079999999999em><span style=top:-3.063em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> permutations turns out to be a bit non-trivial. <a href=/posts/unique-random-numbers/count.cpp>Code is here if you want</a>.</p>
<p>I&rsquo;ve been less thorough with testing really large <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.68333em;vertical-align:0></span><span class="mord mathdefault" style=margin-right:.10903em>N</span></span></span></span>. I dunno. Avalanche isn&rsquo;t really a great test here, necessary but not sufficient type beat.</p>
<h2 id=end>End</h2>
<p>I&rsquo;ve been sitting on this draft unpublished for a while now. I picked up some entropy intuition sometime around writing my low discrepancy noise post, I was trying to figure out why the permutations you can get out of xorshift and LCGs are so bad.</p>
<p>It&rsquo;s invertible, but I have no idea what the inverse function will look like.</p>
<p>I was aiming for the performance to be around the same as Andrew Kensler&rsquo;s permute, the correlated multi-jitter one. By the way, if you understood what I was talking about with the Feistel bits thing you can just eyeball it to get an idea of the permutations you&rsquo;ll get out of it. My permute is about 2x slower, or 1.4x if you let the optimizer precompute the seed hash for you. Given the statistical quality I&rsquo;m after I think this is alright, I can just throw this thing at people and not worry about them seeding it wrong or whatever. I think you can do better speed-wise but I don&rsquo;t know how much better.</p>
<p>And the small <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.68333em;vertical-align:0></span><span class="mord mathdefault" style=margin-right:.10903em>N</span></span></span></span> thing. Why the focus on that? Couldn&rsquo;t you just shuffle an array every time for those? Like, sure, maybe, but really my issue is: if you can&rsquo;t nail the small <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.68333em;vertical-align:0></span><span class="mord mathdefault" style=margin-right:.10903em>N</span></span></span></span> case where it&rsquo;s easy to verify the statistics are good, why would you think large <span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.68333em;vertical-align:0></span><span class="mord mathdefault" style=margin-right:.10903em>N</span></span></span></span> is any better? Okay that&rsquo;s it. ThaNKS for reading</p>
<section class=footnotes role=doc-endnotes>
<hr>
<ol>
<li id=fn:1 role=doc-endnote>
<p>This sidesteps the fact that over the permutation as a whole you get the full bit-width worth of bits of entropy. It&rsquo;s only the path through state space taken by neighbouring values that are bit-deficient. For 8 bits, you&rsquo;d have a 4 bits worth of round functions that each map 4 bits to 4 bits. 16 round functions times 16 possible outputs each is 8 bits total to describe the full permutation. Each round function is totally independent of what the other round functions are doing, and it&rsquo;s only the number of bits required to encode the path a given value takes that is half that required to encode the entire permutation. Really weird.
<br>
<br>
This alone isn&rsquo;t enough to explain the high round counts you see in practice. Interestingly, if you ask instead about the average number of bits that will be flipped then the required round counts come out close to what you see empirically&mldr; but is that just a coincidence??&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:2 role=doc-endnote>
<p>Rejection sampling is faster, and even fast on the GPU as that Michell paper points out. I think it&rsquo;s better statistics-wise too; it just can&rsquo;t be dropped in and used anywhere.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:3 role=doc-endnote>
<p>indistinguishable from an unbiased sample until we exhaust the seed space. Do you care about this distinction? Did I need to add it?&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
</ol>
</section>
</div>
<blockquote class=aside>
<noscript><p style=margin:auto>There might be <a href=https://utteranc.es>utteranc.es</a> comments here when javascript is on.</p></noscript>
<script src=https://utteranc.es/client.js repo=graemephi/graemephi.github.io issue-term=og:title theme=github-light crossorigin=anonymous async></script>
</blockquote>
<h2>More Posts</h2>
<ol reversed>
<li style=list-style:none>
<a href=https://graemephi.github.io/posts/spectrogram-phases/>Spectrogram Phases</a> (2025-09-28)
</li>
<li style=list-style:none>
<a href=https://graemephi.github.io/posts/twelve-tones/>Twelve tones are inescapable</a> (2025-03-31)
</li>
<li style=list-style:none>
<a href=https://graemephi.github.io/posts/modular-forms/>WTF Are Modular Forms</a> (2024-03-25)
</li>
<li style=list-style:none>
<a href=https://graemephi.github.io/posts/some-low-discrepancy-noise-functions/>Some low discrepancy noise functions</a> (2022-08-10)
</li>
<li style=list-style:none>
<a href=https://graemephi.github.io/posts/difference-decay/>Difference Decay</a> (2021-12-29)
</li>
<li style=list-style:none>
<a href=https://graemephi.github.io/posts/stb_ds-string-interning/>stb_ds: string interning</a> (2020-08-27)
</li>
<li style=list-style:none>
<a href=https://graemephi.github.io/posts/deep-sky-object/>deep sky object</a> (2020-05-20)
</li>
<li style=list-style:none>
<a href=https://graemephi.github.io/posts/calculating-lod/>Calculating LOD</a> (2019-12-31)
</li>
<li style=list-style:none>
<a href=https://graemephi.github.io/posts/triangle-dft/>The Discrete Fourier Transform, But With Triangles</a> (2019-12-14)
</li>
<li style=list-style:none>
<a href=https://graemephi.github.io/posts/dumb-tricks-with-phase-inversion/>Dumb Tricks With Phase Inversion</a> (2019-06-02)
</li>
</ol>
<div class=rss-link>
<a href=/index.xml title=RSS>rss</a>
</div>
</div>
</body>
</html>