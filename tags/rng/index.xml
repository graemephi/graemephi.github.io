<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>rng on graeme phillips posting</title><link>https://graemephi.github.io/tags/rng/</link><description>Recent content in rng on graeme phillips posting</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 10 Aug 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://graemephi.github.io/tags/rng/index.xml" rel="self" type="application/rss+xml"/><item><title>Some low discrepancy noise functions</title><link>https://graemephi.github.io/posts/some-low-discrepancy-noise-functions/</link><pubDate>Wed, 10 Aug 2022 00:00:00 +0000</pubDate><guid>https://graemephi.github.io/posts/some-low-discrepancy-noise-functions/</guid><description>&lt;p>This post is about an attempt to generate blue noise at a point: no state, no offline training, just arithmetic on an index. Honestly I don&amp;rsquo;t have a good reason for wanting this but it&amp;rsquo;s probably been at the back of my mind for like 2 years&amp;ndash;it just seemed like it ought to be possible. It turns out to be doable in 1D and with a little lookup table we can push it to 2D.&lt;/p>
&lt;p>The kind of blue noise we&amp;rsquo;re going to get is the classic &amp;ldquo;&lt;a href="https://en.wikipedia.org/wiki/Blue_noise#Blue_noise">3dB per octave&lt;/a>&amp;quot;&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> blue noise, which might turn out to be not all that useful, who knows. But it will also be low discrepancy, and the tricks in this post to keep it that way all the way to 2D are pretty cool I think. The plan is to take a sequence we already know has good discrepancy, whiten its frequency spectrum, and then turn that into blue noise.&lt;/p>
&lt;h2 id="motivating-example-dither">Motivating example: dither&lt;/h2>
&lt;p>So: low discrepancy blue noise. Breaking that down:&lt;/p>
&lt;ul>
&lt;li>Low discrepancy: values the noise takes on are evenly spread out. Read on a bit if this is unclear.&lt;/li>
&lt;li>Blue: no or little low frequencies in the noise&amp;rsquo;s frequency spectrum.&lt;/li>
&lt;li>Noise: unpredictable.&lt;/li>
&lt;/ul>
&lt;p>A problem I had writing this post is that it&amp;rsquo;s not obvious why you&amp;rsquo;d even want noise with these properties, and the technical answer&amp;ndash;reduce variance&amp;ndash;is a bit mystifying. This was a good excuse for me to look at dithering a bit more closely. &lt;a href="https://bartwronski.com/2016/10/30/dithering-in-games-mini-series/">Bart Wronski&lt;/a> has a nice series of posts on dither if it&amp;rsquo;s new to you, but hopefully you can follow this either way.&lt;/p>
&lt;p>Here, we want to represent a 64x64 gray square, with a gray value of &lt;span class="katex">&lt;span class="katex-mathml">&lt;math xmlns="http://www.w3.org/1998/Math/MathML">&lt;semantics>&lt;mrow>&lt;mn>0.5&lt;/mn>&lt;/mrow>&lt;annotation encoding="application/x-tex">0.5&lt;/annotation>&lt;/semantics>&lt;/math>&lt;/span>&lt;span class="katex-html" aria-hidden="true">&lt;span class="base">&lt;span class="strut" style="height:0.64444em;vertical-align:0em;">&lt;/span>&lt;span class="mord">0&lt;/span>&lt;span class="mord">.&lt;/span>&lt;span class="mord">5&lt;/span>&lt;/span>&lt;/span>&lt;/span>, using only black and white pixels. If we know ahead of time that it is solid gray, we could use a checkerboard pattern as a way to approximate &amp;ldquo;gray&amp;rdquo;. But suppose we don&amp;rsquo;t, and we decide to choose whether to make a pixel black or white by drawing a random value in &lt;span class="katex">&lt;span class="katex-mathml">&lt;math xmlns="http://www.w3.org/1998/Math/MathML">&lt;semantics>&lt;mrow>&lt;mo stretchy="false">[&lt;/mo>&lt;mn>0&lt;/mn>&lt;mo separator="true">,&lt;/mo>&lt;mn>1&lt;/mn>&lt;mo stretchy="false">)&lt;/mo>&lt;/mrow>&lt;annotation encoding="application/x-tex">[0,1)&lt;/annotation>&lt;/semantics>&lt;/math>&lt;/span>&lt;span class="katex-html" aria-hidden="true">&lt;span class="base">&lt;span class="strut" style="height:1em;vertical-align:-0.25em;">&lt;/span>&lt;span class="mopen">[&lt;/span>&lt;span class="mord">0&lt;/span>&lt;span class="mpunct">,&lt;/span>&lt;span class="mspace" style="margin-right:0.16666666666666666em;">&lt;/span>&lt;span class="mord">1&lt;/span>&lt;span class="mclose">)&lt;/span>&lt;/span>&lt;/span>&lt;/span> and comparing it to the source pixel; if the random value is less, black, if it&amp;rsquo;s greater, white. Since we&amp;rsquo;re using random values, we can do this multiple times and get a different dither pattern every time. Using some functions I&amp;rsquo;ll get into below, we get this.&lt;/p>
&lt;div class="img-flex" style="justify-content: space-around; width: 648px; left: unset; margin: unset;">
&lt;div style="flex: 0 1 0%;">PRNG&lt;/div>
&lt;div style="flex: 0 1 0%; white-space: nowrap;">Low discrepancy&lt;/div>
&lt;div style="flex: 0 1 0%;">Blue&lt;/div>
&lt;/div>
&lt;div style="display: flex; justify-content: center;">
&lt;img src="https://graemephi.github.io/posts/some-low-discrepancy-noise-functions/dither-grid.png" width="648" height="870" />
&lt;/div>
&lt;p>The PRNG is quite bad. By bad I mean like, to my eye, the third square seems to have too many white pixels. So, yes, it will give 1:1 white and black pixels on average, but that&amp;rsquo;s averaged over all the dithering you could ever do. That&amp;rsquo;s the problem: we don&amp;rsquo;t care about the quality of unrealized dither.&lt;/p>
&lt;p>The middle column, maybe you can convince yourself it looks different, I dunno. It&amp;rsquo;s subtle. If you take it upon yourself to count number of white pixels you&amp;rsquo;ll find that very close to half of them are white, in all four squares. That&amp;rsquo;s low discrepancy. The noise values we got covered &lt;span class="katex">&lt;span class="katex-mathml">&lt;math xmlns="http://www.w3.org/1998/Math/MathML">&lt;semantics>&lt;mrow>&lt;mo stretchy="false">[&lt;/mo>&lt;mn>0&lt;/mn>&lt;mo separator="true">,&lt;/mo>&lt;mn>1&lt;/mn>&lt;mo stretchy="false">)&lt;/mo>&lt;/mrow>&lt;annotation encoding="application/x-tex">[0,1)&lt;/annotation>&lt;/semantics>&lt;/math>&lt;/span>&lt;span class="katex-html" aria-hidden="true">&lt;span class="base">&lt;span class="strut" style="height:1em;vertical-align:-0.25em;">&lt;/span>&lt;span class="mopen">[&lt;/span>&lt;span class="mord">0&lt;/span>&lt;span class="mpunct">,&lt;/span>&lt;span class="mspace" style="margin-right:0.16666666666666666em;">&lt;/span>&lt;span class="mord">1&lt;/span>&lt;span class="mclose">)&lt;/span>&lt;/span>&lt;/span>&lt;/span> much more evenly than random noise. This gives us frequencies of black and white pixels that are always close to the frequencies of the dither we know would be ideal for solid gray.&lt;/p>
&lt;p>However, that&amp;rsquo;s not true over the entire square; there are clumps of black pixels and clumps of white pixels. That&amp;rsquo;s what blue noise addresses. Which you can see just looking at it, right. This gives &lt;em>spatial&lt;/em> frequencies of black and white pixels that better match the ideal dither.&lt;/p>
&lt;p>That&amp;rsquo;s two different kinds of frequency&amp;ndash;one in the histogram sense and another in the spectrum sense. I don&amp;rsquo;t quite know how independent they are. On the one hand, once you have some noise values, you can just rearrange them to get different frequency spectrums with the same discrepancy. On the other, if you want the noise to be low discrepancy &amp;lsquo;everywhere&amp;rsquo;, without any rearrangement, that rules out long lasting low frequency content. What you&amp;rsquo;ll find is the more samples you are willing to wait around for until a given run of draws becomes low discrepancy, the more freedom in shaping the spectrum you&amp;rsquo;ll have. Noise that is low discrepancy everywhere and at all scales has to be blue, though, I think.&lt;/p>
&lt;p>Back to the 64x64 squares. Generating a thousand each, the standard deviation of the number of white pixels in a random PRNG square is 32 (!). It&amp;rsquo;s less than 1 for both the low discrepancy versions. Counting just the top left quarter, at 32x32, it becomes 16, 12, and 2, for the PRNG, white and blue noise respectively. That&amp;rsquo;s what reducing variance means.&lt;/p>
&lt;h2 id="background">Background&lt;/h2>
&lt;p>The API that I want is a counter hash, so a function that takes in an index, hashes it, and spits out a noise value at that index. No state carries forward from index to index, every value is computed independently. Like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">// integer index to 0.32 fixed point
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">uint32_t&lt;/span> &lt;span style="color:#a6e22e">noise&lt;/span>(&lt;span style="color:#66d9ef">uint32_t&lt;/span> index);
&lt;span style="color:#75715e">// usage
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">uint32_t&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">512&lt;/span>; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;span style="color:#75715e">// convert the noise to a float in [0, 1)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">float&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">float&lt;/span>)noise(i) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">1.0&lt;/span>p&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">32f&lt;/span>;
&lt;span style="color:#75715e">// ... do something with x
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We&amp;rsquo;re going to follow &lt;a href="https://jcgt.org/published/0009/04/01/">Practical Hash-based Owen Scrambling&lt;/a> by taking a sequence we already know is low discrepancy and shuffling it. We&amp;rsquo;ll need the &lt;em>nested uniform scramble&lt;/em> from that paper, too. As for the sequence, the golden ratio sequence is &lt;a href="https://marc-b-reynolds.github.io/distribution/2020/01/24/Rank1Pre.html">very easy to compute&lt;/a> in the form I want, so we&amp;rsquo;ll use that.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#f92672">import&lt;/span> np
i32 &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>int32
u32 &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>uint32
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">golden_ratio_sequence&lt;/span>(i: u32) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> u32:
&lt;span style="color:#66d9ef">return&lt;/span> u32(i) &lt;span style="color:#f92672">*&lt;/span> u32(&lt;span style="color:#ae81ff">2654435769&lt;/span>) &lt;span style="color:#75715e"># 0.618... in 0.32 fixed point&lt;/span>
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">reverse_bits32&lt;/span>(x: u32) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> u32:
x &lt;span style="color:#f92672">=&lt;/span> u32(x)
x &lt;span style="color:#f92672">=&lt;/span> ((x &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> u32(&lt;span style="color:#ae81ff">1&lt;/span>)) &lt;span style="color:#f92672">&amp;amp;&lt;/span> u32(&lt;span style="color:#ae81ff">0x55555555&lt;/span>)) &lt;span style="color:#f92672">|&lt;/span> ((x &lt;span style="color:#f92672">&amp;amp;&lt;/span> u32(&lt;span style="color:#ae81ff">0x55555555&lt;/span>)) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> u32(&lt;span style="color:#ae81ff">1&lt;/span>))
x &lt;span style="color:#f92672">=&lt;/span> ((x &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> u32(&lt;span style="color:#ae81ff">2&lt;/span>)) &lt;span style="color:#f92672">&amp;amp;&lt;/span> u32(&lt;span style="color:#ae81ff">0x33333333&lt;/span>)) &lt;span style="color:#f92672">|&lt;/span> ((x &lt;span style="color:#f92672">&amp;amp;&lt;/span> u32(&lt;span style="color:#ae81ff">0x33333333&lt;/span>)) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> u32(&lt;span style="color:#ae81ff">2&lt;/span>))
x &lt;span style="color:#f92672">=&lt;/span> ((x &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> u32(&lt;span style="color:#ae81ff">4&lt;/span>)) &lt;span style="color:#f92672">&amp;amp;&lt;/span> u32(&lt;span style="color:#ae81ff">0x0F0F0F0F&lt;/span>)) &lt;span style="color:#f92672">|&lt;/span> ((x &lt;span style="color:#f92672">&amp;amp;&lt;/span> u32(&lt;span style="color:#ae81ff">0x0F0F0F0F&lt;/span>)) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> u32(&lt;span style="color:#ae81ff">4&lt;/span>))
x &lt;span style="color:#f92672">=&lt;/span> ((x &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> u32(&lt;span style="color:#ae81ff">8&lt;/span>)) &lt;span style="color:#f92672">&amp;amp;&lt;/span> u32(&lt;span style="color:#ae81ff">0x00FF00FF&lt;/span>)) &lt;span style="color:#f92672">|&lt;/span> ((x &lt;span style="color:#f92672">&amp;amp;&lt;/span> u32(&lt;span style="color:#ae81ff">0x00FF00FF&lt;/span>)) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> u32(&lt;span style="color:#ae81ff">8&lt;/span>))
x &lt;span style="color:#f92672">=&lt;/span> ( x &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> u32(&lt;span style="color:#ae81ff">16&lt;/span>) ) &lt;span style="color:#f92672">|&lt;/span> ( x &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> u32(&lt;span style="color:#ae81ff">16&lt;/span>))
&lt;span style="color:#66d9ef">return&lt;/span> x
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">nested_uniform_scramble&lt;/span>(x: u32) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> u32:
x &lt;span style="color:#f92672">=&lt;/span> reverse_bits32(x)
x &lt;span style="color:#f92672">^=&lt;/span> x &lt;span style="color:#f92672">*&lt;/span> u32(&lt;span style="color:#ae81ff">0x6c50b47c&lt;/span>)
x &lt;span style="color:#f92672">^=&lt;/span> x &lt;span style="color:#f92672">*&lt;/span> u32(&lt;span style="color:#ae81ff">0xb82f1e52&lt;/span>)
x &lt;span style="color:#f92672">^=&lt;/span> x &lt;span style="color:#f92672">*&lt;/span> u32(&lt;span style="color:#ae81ff">0xc7afe638&lt;/span>)
x &lt;span style="color:#f92672">^=&lt;/span> x &lt;span style="color:#f92672">*&lt;/span> u32(&lt;span style="color:#ae81ff">0x8d22f6e6&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> reverse_bits32(x)
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">okay_blue_noise&lt;/span>(i: u32) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> u32:
&lt;span style="color:#66d9ef">return&lt;/span> golden_ratio_sequence(nested_uniform_scramble(i))
&lt;/code>&lt;/pre>&lt;/div>&lt;p>You can get a reordering of any sequence you like by hashing the index with &lt;em>nested uniforms scramble&lt;/em>.&lt;/p>
&lt;p>It&amp;rsquo;s a bit intimidating, but the important thing about it is each hex constant there is an even number. In binary, multiplying by an even number sends bits to the left, so each xor permutes bits in a low-to-high direction. The authors wanted to permute bits high-to-low, and so reverse the bit order before and after. So, it&amp;rsquo;s a hash, where the action of each bit on the hash is constrained to only permute bits below itself. And the &lt;a href="http://burtleburtle.net/bob/rand/talksmall.html">xors are invertible&lt;/a>, meaning each input maps to a unique output.&lt;/p>
&lt;p>A consequence of this that can give you some intuition for what it does is that the high bit of the input is always preserved. So, as a counter hash, the first &lt;span class="katex">&lt;span class="katex-mathml">&lt;math xmlns="http://www.w3.org/1998/Math/MathML">&lt;semantics>&lt;mrow>&lt;msup>&lt;mn>2&lt;/mn>&lt;mi>n&lt;/mi>&lt;/msup>&lt;/mrow>&lt;annotation encoding="application/x-tex">2^n&lt;/annotation>&lt;/semantics>&lt;/math>&lt;/span>&lt;span class="katex-html" aria-hidden="true">&lt;span class="base">&lt;span class="strut" style="height:0.664392em;vertical-align:0em;">&lt;/span>&lt;span class="mord">&lt;span class="mord">2&lt;/span>&lt;span class="msupsub">&lt;span class="vlist-t">&lt;span class="vlist-r">&lt;span class="vlist" style="height:0.664392em;">&lt;span style="top:-3.063em;margin-right:0.05em;">&lt;span class="pstrut" style="height:2.7em;">&lt;/span>&lt;span class="sizing reset-size6 size3 mtight">&lt;span class="mord mathdefault mtight">n&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span> inputs map to &lt;code>u32&lt;/code>s below &lt;span class="katex">&lt;span class="katex-mathml">&lt;math xmlns="http://www.w3.org/1998/Math/MathML">&lt;semantics>&lt;mrow>&lt;msup>&lt;mn>2&lt;/mn>&lt;mi>n&lt;/mi>&lt;/msup>&lt;/mrow>&lt;annotation encoding="application/x-tex">2^n&lt;/annotation>&lt;/semantics>&lt;/math>&lt;/span>&lt;span class="katex-html" aria-hidden="true">&lt;span class="base">&lt;span class="strut" style="height:0.664392em;vertical-align:0em;">&lt;/span>&lt;span class="mord">&lt;span class="mord">2&lt;/span>&lt;span class="msupsub">&lt;span class="vlist-t">&lt;span class="vlist-r">&lt;span class="vlist" style="height:0.664392em;">&lt;span style="top:-3.063em;margin-right:0.05em;">&lt;span class="pstrut" style="height:2.7em;">&lt;/span>&lt;span class="sizing reset-size6 size3 mtight">&lt;span class="mord mathdefault mtight">n&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>. And since you know that holds for &lt;span class="katex">&lt;span class="katex-mathml">&lt;math xmlns="http://www.w3.org/1998/Math/MathML">&lt;semantics>&lt;mrow>&lt;msup>&lt;mn>2&lt;/mn>&lt;mrow>&lt;mi>n&lt;/mi>&lt;mo>+&lt;/mo>&lt;mn>1&lt;/mn>&lt;/mrow>&lt;/msup>&lt;/mrow>&lt;annotation encoding="application/x-tex">2^{n+1}&lt;/annotation>&lt;/semantics>&lt;/math>&lt;/span>&lt;span class="katex-html" aria-hidden="true">&lt;span class="base">&lt;span class="strut" style="height:0.8141079999999999em;vertical-align:0em;">&lt;/span>&lt;span class="mord">&lt;span class="mord">2&lt;/span>&lt;span class="msupsub">&lt;span class="vlist-t">&lt;span class="vlist-r">&lt;span class="vlist" style="height:0.8141079999999999em;">&lt;span style="top:-3.063em;margin-right:0.05em;">&lt;span class="pstrut" style="height:2.7em;">&lt;/span>&lt;span class="sizing reset-size6 size3 mtight">&lt;span class="mord mtight">&lt;span class="mord mathdefault mtight">n&lt;/span>&lt;span class="mbin mtight">+&lt;/span>&lt;span class="mord mtight">1&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span> as well, you also get that &lt;span class="katex">&lt;span class="katex-mathml">&lt;math xmlns="http://www.w3.org/1998/Math/MathML">&lt;semantics>&lt;mrow>&lt;mo stretchy="false">[&lt;/mo>&lt;msup>&lt;mn>2&lt;/mn>&lt;mi>n&lt;/mi>&lt;/msup>&lt;mo separator="true">,&lt;/mo>&lt;msup>&lt;mn>2&lt;/mn>&lt;mrow>&lt;mi>n&lt;/mi>&lt;mo>+&lt;/mo>&lt;mn>1&lt;/mn>&lt;/mrow>&lt;/msup>&lt;mo stretchy="false">]&lt;/mo>&lt;/mrow>&lt;annotation encoding="application/x-tex">[2^n, 2^{n+1}]&lt;/annotation>&lt;/semantics>&lt;/math>&lt;/span>&lt;span class="katex-html" aria-hidden="true">&lt;span class="base">&lt;span class="strut" style="height:1.064108em;vertical-align:-0.25em;">&lt;/span>&lt;span class="mopen">[&lt;/span>&lt;span class="mord">&lt;span class="mord">2&lt;/span>&lt;span class="msupsub">&lt;span class="vlist-t">&lt;span class="vlist-r">&lt;span class="vlist" style="height:0.664392em;">&lt;span style="top:-3.063em;margin-right:0.05em;">&lt;span class="pstrut" style="height:2.7em;">&lt;/span>&lt;span class="sizing reset-size6 size3 mtight">&lt;span class="mord mathdefault mtight">n&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;span class="mpunct">,&lt;/span>&lt;span class="mspace" style="margin-right:0.16666666666666666em;">&lt;/span>&lt;span class="mord">&lt;span class="mord">2&lt;/span>&lt;span class="msupsub">&lt;span class="vlist-t">&lt;span class="vlist-r">&lt;span class="vlist" style="height:0.8141079999999999em;">&lt;span style="top:-3.063em;margin-right:0.05em;">&lt;span class="pstrut" style="height:2.7em;">&lt;/span>&lt;span class="sizing reset-size6 size3 mtight">&lt;span class="mord mtight">&lt;span class="mord mathdefault mtight">n&lt;/span>&lt;span class="mbin mtight">+&lt;/span>&lt;span class="mord mtight">1&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;span class="mclose">]&lt;/span>&lt;/span>&lt;/span>&lt;/span> maps to &lt;span class="katex">&lt;span class="katex-mathml">&lt;math xmlns="http://www.w3.org/1998/Math/MathML">&lt;semantics>&lt;mrow>&lt;mo stretchy="false">[&lt;/mo>&lt;msup>&lt;mn>2&lt;/mn>&lt;mi>n&lt;/mi>&lt;/msup>&lt;mo separator="true">,&lt;/mo>&lt;msup>&lt;mn>2&lt;/mn>&lt;mrow>&lt;mi>n&lt;/mi>&lt;mo>+&lt;/mo>&lt;mn>1&lt;/mn>&lt;/mrow>&lt;/msup>&lt;mo stretchy="false">]&lt;/mo>&lt;/mrow>&lt;annotation encoding="application/x-tex">[2^n, 2^{n+1}]&lt;/annotation>&lt;/semantics>&lt;/math>&lt;/span>&lt;span class="katex-html" aria-hidden="true">&lt;span class="base">&lt;span class="strut" style="height:1.064108em;vertical-align:-0.25em;">&lt;/span>&lt;span class="mopen">[&lt;/span>&lt;span class="mord">&lt;span class="mord">2&lt;/span>&lt;span class="msupsub">&lt;span class="vlist-t">&lt;span class="vlist-r">&lt;span class="vlist" style="height:0.664392em;">&lt;span style="top:-3.063em;margin-right:0.05em;">&lt;span class="pstrut" style="height:2.7em;">&lt;/span>&lt;span class="sizing reset-size6 size3 mtight">&lt;span class="mord mathdefault mtight">n&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;span class="mpunct">,&lt;/span>&lt;span class="mspace" style="margin-right:0.16666666666666666em;">&lt;/span>&lt;span class="mord">&lt;span class="mord">2&lt;/span>&lt;span class="msupsub">&lt;span class="vlist-t">&lt;span class="vlist-r">&lt;span class="vlist" style="height:0.8141079999999999em;">&lt;span style="top:-3.063em;margin-right:0.05em;">&lt;span class="pstrut" style="height:2.7em;">&lt;/span>&lt;span class="sizing reset-size6 size3 mtight">&lt;span class="mord mtight">&lt;span class="mord mathdefault mtight">n&lt;/span>&lt;span class="mbin mtight">+&lt;/span>&lt;span class="mord mtight">1&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;span class="mclose">]&lt;/span>&lt;/span>&lt;/span>&lt;/span>. In these intervals, the shuffled sequence produces the same values as the underlying sequence, just in a different order. This doesn&amp;rsquo;t fully explain its behaviour as a hash but it&amp;rsquo;s enough for us to get going with.&lt;/p>
&lt;p>By the way, you can also think of the (fixed point) golden ratio sequence as a shuffle of the integers in &lt;code>u32&lt;/code>. They all appear exactly once.&lt;/p>
&lt;p>This has all been background, but before we get to the good stuff, let&amp;rsquo;s look at what we have:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#f92672">import&lt;/span> matplotlib.pyplot &lt;span style="color:#66d9ef">as&lt;/span> plt
plt&lt;span style="color:#f92672">.&lt;/span>rcParams[&lt;span style="color:#e6db74">&amp;#39;figure.figsize&amp;#39;&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#ae81ff">9&lt;/span>,&lt;span style="color:#ae81ff">2&lt;/span>)
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">spectrum&lt;/span>(seq):
S &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>fft&lt;span style="color:#f92672">.&lt;/span>rfft(&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">*&lt;/span> seq &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1.0&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>abs(S) &lt;span style="color:#f92672">/&lt;/span> len(seq)
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">plots&lt;/span>(name: str, seq_u32):
seq &lt;span style="color:#f92672">=&lt;/span> seq_u32 &lt;span style="color:#f92672">*&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>ldexp(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">32&lt;/span>)
figure, (histogram_axis, spectrum_axis) &lt;span style="color:#f92672">=&lt;/span> plt&lt;span style="color:#f92672">.&lt;/span>subplots(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>)
histogram_axis&lt;span style="color:#f92672">.&lt;/span>hist(seq, &lt;span style="color:#ae81ff">128&lt;/span>)
histogram_axis&lt;span style="color:#f92672">.&lt;/span>set_xlabel(&lt;span style="color:#e6db74">f&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">{&lt;/span>name&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> histogram: &lt;/span>&lt;span style="color:#e6db74">{&lt;/span>len(seq)&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> points&amp;#34;&lt;/span>)
dft &lt;span style="color:#f92672">=&lt;/span> spectrum(seq)
spectrum_axis&lt;span style="color:#f92672">.&lt;/span>plot(dft)
spectrum_axis&lt;span style="color:#f92672">.&lt;/span>set_xlabel(&lt;span style="color:#e6db74">f&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">{&lt;/span>name&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> spectrum: &lt;/span>&lt;span style="color:#e6db74">{&lt;/span>len(seq)&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> points&amp;#34;&lt;/span>)
n &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">3333&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Bad histogram&amp;hellip;&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#f92672">from&lt;/span> numpy.random &lt;span style="color:#f92672">import&lt;/span> default_rng
rng &lt;span style="color:#f92672">=&lt;/span> default_rng()
plots(&lt;span style="color:#e6db74">&amp;#34;PRNG&amp;#34;&lt;/span>, rng&lt;span style="color:#f92672">.&lt;/span>integers(&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0x1_0000_0000&lt;/span>, size&lt;span style="color:#f92672">=&lt;/span>n))
&lt;/code>&lt;/pre>&lt;/div>
&lt;div style="display: flex; justify-content: center;">
&lt;img src="https://graemephi.github.io/posts/some-low-discrepancy-noise-functions/PRNG.png" width="744" height="217" />
&lt;/div>
&lt;p>Bad spectrum&amp;hellip;&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">i &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>arange(n)
plots(&lt;span style="color:#e6db74">&amp;#34;golden ratio sequence&amp;#34;&lt;/span>, golden_ratio_sequence(i))
&lt;/code>&lt;/pre>&lt;/div>
&lt;div style="display: flex; justify-content: center;">
&lt;img src="https://graemephi.github.io/posts/some-low-discrepancy-noise-functions/golden-ratio-sequence.png" width="744" height="217" />
&lt;/div>
&lt;p>Noise with a flat histogram?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">plots(&lt;span style="color:#e6db74">&amp;#34;nested uniform scramble-shuffled grs&amp;#34;&lt;/span>, okay_blue_noise(i))
&lt;/code>&lt;/pre>&lt;/div>
&lt;div style="display: flex; justify-content: center;">
&lt;img src="https://graemephi.github.io/posts/some-low-discrepancy-noise-functions/nus-shuffled-grs.png" width="744" height="217" />
&lt;/div>
&lt;p>This already has some low frequency attenuation. Well, if you drop the last bit reversal step and the golden ratio sequence and instead use it directly, not as a shuffle, it comes out even better. But my plan here is to clear the way by getting to white noise, and to use that as a base for more noise colours, so forget I said anything.&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>&lt;/p>
&lt;h2 id="xorshift">Xorshift&lt;/h2>
&lt;p>We need more unpredictability. To that end, let&amp;rsquo;s look at using xorshift as a counter hash. Specifically, lets look at the low bits.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">xorshift&lt;/span>(x: u32) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> u32:
x &lt;span style="color:#f92672">=&lt;/span> u32(x)
x &lt;span style="color:#f92672">^=&lt;/span> x &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> u32(&lt;span style="color:#ae81ff">13&lt;/span>)
x &lt;span style="color:#f92672">^=&lt;/span> x &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> u32(&lt;span style="color:#ae81ff">17&lt;/span>)
x &lt;span style="color:#f92672">^=&lt;/span> x &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> u32(&lt;span style="color:#ae81ff">5&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> x
i &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>arange(&lt;span style="color:#ae81ff">16&lt;/span>)
print(i)
print(xorshift(i) &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">0b1111&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code class="language-terminal" data-lang="terminal">[ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15]
[ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15]
&lt;/code>&lt;/pre>&lt;p>Uh, hold on,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">xorshift(i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">64&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">16&lt;/span>) &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">0b1111&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code class="language-terminal" data-lang="terminal">[ 5 4 7 6 1 0 3 2 13 12 15 14 9 8 11 10]
&lt;/code>&lt;/pre>&lt;p>The lower 4 bits are a (not very random) permutation of the original 4-bit sequence!! The Xorshift* variants preserve this property and is at least superficially random-looking so let&amp;rsquo;s use that instead from now on (&lt;a href="https://gist.github.com/imneme/9b769cefccac1f2bd728596da3a856dd">constant from Melissa O&amp;rsquo;Neill&lt;/a>):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">xorshift_star&lt;/span>(x: u32) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> u32:
x &lt;span style="color:#f92672">=&lt;/span> u32(x)
x &lt;span style="color:#f92672">^=&lt;/span> x &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> u32(&lt;span style="color:#ae81ff">13&lt;/span>)
x &lt;span style="color:#f92672">^=&lt;/span> x &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> u32(&lt;span style="color:#ae81ff">17&lt;/span>)
x &lt;span style="color:#f92672">^=&lt;/span> x &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> u32(&lt;span style="color:#ae81ff">5&lt;/span>)
x &lt;span style="color:#f92672">*=&lt;/span> u32(&lt;span style="color:#ae81ff">0x9e02ad0d&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> x
xorshift_star(i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">64&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">16&lt;/span>) &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">0b1111&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code class="language-terminal" data-lang="terminal">[ 1 4 11 14 13 0 7 10 9 12 3 6 5 8 15 2]
&lt;/code>&lt;/pre>&lt;p>This works for powers of two up to &lt;span class="katex">&lt;span class="katex-mathml">&lt;math xmlns="http://www.w3.org/1998/Math/MathML">&lt;semantics>&lt;mrow>&lt;msup>&lt;mn>2&lt;/mn>&lt;mn>16&lt;/mn>&lt;/msup>&lt;/mrow>&lt;annotation encoding="application/x-tex">2^{16}&lt;/annotation>&lt;/semantics>&lt;/math>&lt;/span>&lt;span class="katex-html" aria-hidden="true">&lt;span class="base">&lt;span class="strut" style="height:0.8141079999999999em;vertical-align:0em;">&lt;/span>&lt;span class="mord">&lt;span class="mord">2&lt;/span>&lt;span class="msupsub">&lt;span class="vlist-t">&lt;span class="vlist-r">&lt;span class="vlist" style="height:0.8141079999999999em;">&lt;span style="top:-3.063em;margin-right:0.05em;">&lt;span class="pstrut" style="height:2.7em;">&lt;/span>&lt;span class="sizing reset-size6 size3 mtight">&lt;span class="mord mtight">&lt;span class="mord mtight">1&lt;/span>&lt;span class="mord mtight">6&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>. This isn&amp;rsquo;t a good way of generating permutations&amp;ndash;it can&amp;rsquo;t make all that many&amp;ndash;but we don&amp;rsquo;t need it to be good. &lt;a href="https://en.wikipedia.org/wiki/Linear_congruential_generator">LCGs&lt;/a> work this way, too.&lt;/p>
&lt;p>Now, because of this we can bestow xorshift with the high-bit-preserving property&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup> of &lt;em>nested uniform scramble&lt;/em> by fixing the high bit and masking off any new bits placed above it. And we know that when we do this, every input still maps to a unique output, so long as we only scramble the lower 2 bytes. Using all 16 bits is way too random, so we can cap the number of bits we allow to be scrambled this way, and use the rest as a seed that selects a permutation. Looks like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">all_ones_below_high_bit&lt;/span>(x: u32) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> u32:
x &lt;span style="color:#f92672">=&lt;/span> u32(x)
x &lt;span style="color:#f92672">|=&lt;/span> (x &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> u32(&lt;span style="color:#ae81ff">16&lt;/span>))
x &lt;span style="color:#f92672">|=&lt;/span> (x &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> u32(&lt;span style="color:#ae81ff">8&lt;/span>))
x &lt;span style="color:#f92672">|=&lt;/span> (x &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> u32(&lt;span style="color:#ae81ff">4&lt;/span>))
x &lt;span style="color:#f92672">|=&lt;/span> (x &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> u32(&lt;span style="color:#ae81ff">2&lt;/span>))
x &lt;span style="color:#f92672">|=&lt;/span> (x &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> u32(&lt;span style="color:#ae81ff">1&lt;/span>))
&lt;span style="color:#75715e"># this last shift: the high bit is not included&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> x &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> u32(&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">unfolded_masked_xorshift&lt;/span>(x: u32, cap_mask: u32) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> u32:
mask &lt;span style="color:#f92672">=&lt;/span> all_ones_below_high_bit(x &lt;span style="color:#f92672">&amp;amp;&lt;/span> cap_mask)
upper &lt;span style="color:#f92672">=&lt;/span> x &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#f92672">~&lt;/span>mask
lower &lt;span style="color:#f92672">=&lt;/span> xorshift_star(x) &lt;span style="color:#f92672">&amp;amp;&lt;/span> mask
result &lt;span style="color:#f92672">=&lt;/span> upper &lt;span style="color:#f92672">+&lt;/span> lower
&lt;span style="color:#66d9ef">return&lt;/span> result
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Every bit we include in this scramble increases discrepancy&amp;ndash;bits can permute bits to their left, here. We can claw back a bit by treating the high bit of &lt;code>cap_mask&lt;/code> as a kind of sign bit and flipping all this logic to work backwards when its set.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">masked_xorshift&lt;/span>(x: u32, bits: u32 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> u32:
&lt;span style="color:#75715e"># all ones if (x &amp;amp; 0x100) == 0x100, all zeros otherwise&lt;/span>
sign_mask &lt;span style="color:#f92672">=&lt;/span> i32(x &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> u32(&lt;span style="color:#ae81ff">31&lt;/span> &lt;span style="color:#f92672">-&lt;/span> bits)) &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> i32(&lt;span style="color:#ae81ff">31&lt;/span>)
sign_mask &lt;span style="color:#f92672">=&lt;/span> u32(sign_mask)
cap_mask &lt;span style="color:#f92672">=&lt;/span> u32((&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> bits) &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> unfolded_masked_xorshift(x &lt;span style="color:#f92672">^&lt;/span> sign_mask, cap_mask) &lt;span style="color:#f92672">^&lt;/span> sign_mask
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This is all pretty abstract. You can see what it does by plotting the difference with its input:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">i &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>arange(&lt;span style="color:#ae81ff">1024&lt;/span>)
plt&lt;span style="color:#f92672">.&lt;/span>plot(i &lt;span style="color:#f92672">-&lt;/span> masked_xorshift(i))
&lt;/code>&lt;/pre>&lt;/div>
&lt;div style="display: flex; justify-content: center;">
&lt;img src="https://graemephi.github.io/posts/some-low-discrepancy-noise-functions/xor-diff.png" width="900" height="200" />
&lt;/div>
&lt;p>As a shuffle, this shows you where elements are being moved to, relative to their original position. With &lt;code>bits = 8&lt;/code>, that distance is never more than 128. So, while this scramble doesn&amp;rsquo;t have all the nice properties of &lt;em>nested uniform scramble&lt;/em>, we do get a version of the &lt;span class="katex">&lt;span class="katex-mathml">&lt;math xmlns="http://www.w3.org/1998/Math/MathML">&lt;semantics>&lt;mrow>&lt;mo stretchy="false">[&lt;/mo>&lt;msup>&lt;mn>2&lt;/mn>&lt;mi>n&lt;/mi>&lt;/msup>&lt;mo separator="true">,&lt;/mo>&lt;msup>&lt;mn>2&lt;/mn>&lt;mrow>&lt;mi>n&lt;/mi>&lt;mo>+&lt;/mo>&lt;mn>1&lt;/mn>&lt;/mrow>&lt;/msup>&lt;mo stretchy="false">]&lt;/mo>&lt;/mrow>&lt;annotation encoding="application/x-tex">[2^n, 2^{n+1}]&lt;/annotation>&lt;/semantics>&lt;/math>&lt;/span>&lt;span class="katex-html" aria-hidden="true">&lt;span class="base">&lt;span class="strut" style="height:1.064108em;vertical-align:-0.25em;">&lt;/span>&lt;span class="mopen">[&lt;/span>&lt;span class="mord">&lt;span class="mord">2&lt;/span>&lt;span class="msupsub">&lt;span class="vlist-t">&lt;span class="vlist-r">&lt;span class="vlist" style="height:0.664392em;">&lt;span style="top:-3.063em;margin-right:0.05em;">&lt;span class="pstrut" style="height:2.7em;">&lt;/span>&lt;span class="sizing reset-size6 size3 mtight">&lt;span class="mord mathdefault mtight">n&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;span class="mpunct">,&lt;/span>&lt;span class="mspace" style="margin-right:0.16666666666666666em;">&lt;/span>&lt;span class="mord">&lt;span class="mord">2&lt;/span>&lt;span class="msupsub">&lt;span class="vlist-t">&lt;span class="vlist-r">&lt;span class="vlist" style="height:0.8141079999999999em;">&lt;span style="top:-3.063em;margin-right:0.05em;">&lt;span class="pstrut" style="height:2.7em;">&lt;/span>&lt;span class="sizing reset-size6 size3 mtight">&lt;span class="mord mtight">&lt;span class="mord mathdefault mtight">n&lt;/span>&lt;span class="mbin mtight">+&lt;/span>&lt;span class="mord mtight">1&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;span class="mclose">]&lt;/span>&lt;/span>&lt;/span>&lt;/span> bijection property that repeats inside every chunk of size 256. So discrepancy-wise it&amp;rsquo;s kind of bad, but we can bound the bad with &lt;code>bits&lt;/code>.&lt;/p>
&lt;p>Now we&amp;rsquo;ve got low discrepancy white noise:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">white_shuffle&lt;/span>(i: u32) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> u32:
s &lt;span style="color:#f92672">=&lt;/span> i
s &lt;span style="color:#f92672">=&lt;/span> masked_xorshift(s)
s &lt;span style="color:#f92672">=&lt;/span> nested_uniform_scramble(s)
&lt;span style="color:#66d9ef">return&lt;/span> s
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">white&lt;/span>(i: u32) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> u32:
&lt;span style="color:#66d9ef">return&lt;/span> golden_ratio_sequence(white_shuffle(i))
i &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>arange(&lt;span style="color:#ae81ff">3333&lt;/span>)
plots(&lt;span style="color:#e6db74">&amp;#34;white&amp;#34;&lt;/span>, white(i))
&lt;/code>&lt;/pre>&lt;/div>
&lt;div style="display: flex; justify-content: center;">
&lt;img src="https://graemephi.github.io/posts/some-low-discrepancy-noise-functions/white.png" width="744" height="217" />
&lt;/div>
&lt;p>Look closely at the lowest frequencies of the spectrum. There is a slight gradient away from zero. This is what &lt;code>bits&lt;/code> controls: the slope of that gradient. I found that at 11 bits it&amp;rsquo;s qualitatively pure white noise with no obvious correlations (&amp;hellip; aside from an usually flat histogram). But it&amp;rsquo;s just too much random. For example, the variance in the dither example really suffers. And variance is what we care about.&lt;/p>
&lt;p>Next: gotta eyeball it in 2D. You gotta.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">plt&lt;span style="color:#f92672">.&lt;/span>rcParams[&lt;span style="color:#e6db74">&amp;#39;image.cmap&amp;#39;&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;gray&amp;#39;&lt;/span>
plt&lt;span style="color:#f92672">.&lt;/span>rcParams[&lt;span style="color:#e6db74">&amp;#39;image.interpolation&amp;#39;&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;none&amp;#39;&lt;/span>
px &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">/&lt;/span>plt&lt;span style="color:#f92672">.&lt;/span>rcParams[&lt;span style="color:#e6db74">&amp;#39;figure.dpi&amp;#39;&lt;/span>]
n &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">512&lt;/span>
i &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>arange(n&lt;span style="color:#f92672">*&lt;/span>n)
f, ax &lt;span style="color:#f92672">=&lt;/span> plt&lt;span style="color:#f92672">.&lt;/span>subplots(figsize&lt;span style="color:#f92672">=&lt;/span>(n&lt;span style="color:#f92672">*&lt;/span>px, n&lt;span style="color:#f92672">*&lt;/span>px)); ax&lt;span style="color:#f92672">.&lt;/span>axis(&lt;span style="color:#e6db74">&amp;#39;off&amp;#39;&lt;/span>)
ax&lt;span style="color:#f92672">.&lt;/span>imshow(white(i)&lt;span style="color:#f92672">.&lt;/span>reshape((n,n)) &lt;span style="color:#f92672">*&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>ldexp(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">32&lt;/span>))
&lt;/code>&lt;/pre>&lt;/div>
&lt;div style="display: flex; justify-content: center;">
&lt;img src="https://graemephi.github.io/posts/some-low-discrepancy-noise-functions/white2d-bad.png" width="512" height="512" />
&lt;/div>
&lt;p>Ah. The edges. It&amp;rsquo;s bad. Okay, that&amp;rsquo;s our choice of &lt;code>bits&lt;/code>. It&amp;rsquo;s too small. But we don&amp;rsquo;t have to increase &lt;code>bits&lt;/code>, we can get away with doing another nested uniform scramble. This is kind of painful on x64, where bit reversal spews instructions everywhere, but, eh. There&amp;rsquo;s a trade-off between performance and discrepancy here and I completely lack any insight on it.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">white_shuffle&lt;/span>(i: u32) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> u32:
s &lt;span style="color:#f92672">=&lt;/span> i
s &lt;span style="color:#f92672">=&lt;/span> nested_uniform_scramble(s)
s &lt;span style="color:#f92672">=&lt;/span> masked_xorshift(s)
s &lt;span style="color:#f92672">=&lt;/span> nested_uniform_scramble(s)
&lt;span style="color:#66d9ef">return&lt;/span> s
f, ax &lt;span style="color:#f92672">=&lt;/span> plt&lt;span style="color:#f92672">.&lt;/span>subplots(figsize&lt;span style="color:#f92672">=&lt;/span>(n&lt;span style="color:#f92672">*&lt;/span>px, n&lt;span style="color:#f92672">*&lt;/span>px)); ax&lt;span style="color:#f92672">.&lt;/span>axis(&lt;span style="color:#e6db74">&amp;#39;off&amp;#39;&lt;/span>)
ax&lt;span style="color:#f92672">.&lt;/span>imshow(white(i)&lt;span style="color:#f92672">.&lt;/span>reshape((n,n)) &lt;span style="color:#f92672">*&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>ldexp(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">32&lt;/span>))
&lt;/code>&lt;/pre>&lt;/div>
&lt;div style="display: flex; justify-content: center;">
&lt;img src="https://graemephi.github.io/posts/some-low-discrepancy-noise-functions/white2d.png" width="512" height="512" />
&lt;/div>
&lt;p>👍&lt;/p>
&lt;h2 id="blue-noise">Blue noise&lt;/h2>
&lt;p>Now, to transmute this into blue noise. Filtering the noise directly destroys low discrepancy, so no perfectly tuned cut off frequency and ripple here. But I think what I&amp;rsquo;m about to suggest might seem to come out of nowhere for some people. With that in mind, here&amp;rsquo;s what I was thinking about when I realised this: the &lt;em>unshuffled&lt;/em> golden ratio sequence has the property that&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">golden_ratio_sequence(i &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">-&lt;/span> golden_ratio_sequence(i)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>In other words, you can go backwards from zero, and it&amp;rsquo;s the same, just inverted around &lt;span class="katex">&lt;span class="katex-mathml">&lt;math xmlns="http://www.w3.org/1998/Math/MathML">&lt;semantics>&lt;mrow>&lt;mn>0.5&lt;/mn>&lt;/mrow>&lt;annotation encoding="application/x-tex">0.5&lt;/annotation>&lt;/semantics>&lt;/math>&lt;/span>&lt;span class="katex-html" aria-hidden="true">&lt;span class="base">&lt;span class="strut" style="height:0.64444em;vertical-align:0em;">&lt;/span>&lt;span class="mord">0&lt;/span>&lt;span class="mord">.&lt;/span>&lt;span class="mord">5&lt;/span>&lt;/span>&lt;/span>&lt;/span>. So what if we interleaved the forwards sequence with the backwards sequence? The two sequences would meet in the middle. Seems natural, right?&lt;/p>
&lt;p>This turns out to do something very specific in the frequency domain: it fills in the new frequency bins&amp;ndash;twice as many samples, twice as many bins&amp;ndash;with a copy of the frequency spectrum then high pass filters the whole thing. This is entirely due to the right hand side of the above equation, so when we use that form, it also works on the &lt;em>shuffled&lt;/em> sequence.&lt;/p>
&lt;p>But why!? If you&amp;rsquo;re comfortable with DSP this can be hand-waved as being the composition of three steps: zero-stuffing to &lt;a href="https://bartwronski.com/2021/02/15/bilinear-down-upsampling-pixel-grids-and-that-half-pixel-offset/">repeat the frequency spectrum&lt;/a>&lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup>, applying the simple low-pass filter &lt;span class="katex">&lt;span class="katex-mathml">&lt;math xmlns="http://www.w3.org/1998/Math/MathML">&lt;semantics>&lt;mrow>&lt;mo stretchy="false">[&lt;/mo>&lt;mn>1&lt;/mn>&lt;mo separator="true">,&lt;/mo>&lt;mn>1&lt;/mn>&lt;mo stretchy="false">]&lt;/mo>&lt;/mrow>&lt;annotation encoding="application/x-tex">[1, 1]&lt;/annotation>&lt;/semantics>&lt;/math>&lt;/span>&lt;span class="katex-html" aria-hidden="true">&lt;span class="base">&lt;span class="strut" style="height:1em;vertical-align:-0.25em;">&lt;/span>&lt;span class="mopen">[&lt;/span>&lt;span class="mord">1&lt;/span>&lt;span class="mpunct">,&lt;/span>&lt;span class="mspace" style="margin-right:0.16666666666666666em;">&lt;/span>&lt;span class="mord">1&lt;/span>&lt;span class="mclose">]&lt;/span>&lt;/span>&lt;/span>&lt;/span>, and then reversing the frequency spectrum by inverting every second sample. This turns the low-pass filter we just applied into a high-pass filter.&lt;/p>
&lt;p>Even so, that last bit might need more explaining if you haven&amp;rsquo;t seen it before. This is directed at DSP people (don&amp;rsquo;t worry about it). First, in this context, &lt;span class="katex-display">&lt;span class="katex">&lt;span class="katex-mathml">&lt;math xmlns="http://www.w3.org/1998/Math/MathML">&lt;semantics>&lt;mrow>&lt;mn>1&lt;/mn>&lt;mo>−&lt;/mo>&lt;msub>&lt;mi>a&lt;/mi>&lt;mi>i&lt;/mi>&lt;/msub>&lt;mo>=&lt;/mo>&lt;mo>−&lt;/mo>&lt;mn>1&lt;/mn>&lt;mo>⋅&lt;/mo>&lt;msub>&lt;mi>a&lt;/mi>&lt;mi>i&lt;/mi>&lt;/msub>&lt;mo separator="true">,&lt;/mo>&lt;/mrow>&lt;annotation encoding="application/x-tex">1 - a_i=-1\cdot a_i,&lt;/annotation>&lt;/semantics>&lt;/math>&lt;/span>&lt;span class="katex-html" aria-hidden="true">&lt;span class="base">&lt;span class="strut" style="height:0.72777em;vertical-align:-0.08333em;">&lt;/span>&lt;span class="mord">1&lt;/span>&lt;span class="mspace" style="margin-right:0.2222222222222222em;">&lt;/span>&lt;span class="mbin">−&lt;/span>&lt;span class="mspace" style="margin-right:0.2222222222222222em;">&lt;/span>&lt;/span>&lt;span class="base">&lt;span class="strut" style="height:0.58056em;vertical-align:-0.15em;">&lt;/span>&lt;span class="mord">&lt;span class="mord mathdefault">a&lt;/span>&lt;span class="msupsub">&lt;span class="vlist-t vlist-t2">&lt;span class="vlist-r">&lt;span class="vlist" style="height:0.31166399999999994em;">&lt;span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;">&lt;span class="pstrut" style="height:2.7em;">&lt;/span>&lt;span class="sizing reset-size6 size3 mtight">&lt;span class="mord mathdefault mtight">i&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;span class="vlist-s">​&lt;/span>&lt;/span>&lt;span class="vlist-r">&lt;span class="vlist" style="height:0.15em;">&lt;span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;span class="mspace" style="margin-right:0.2777777777777778em;">&lt;/span>&lt;span class="mrel">=&lt;/span>&lt;span class="mspace" style="margin-right:0.2777777777777778em;">&lt;/span>&lt;/span>&lt;span class="base">&lt;span class="strut" style="height:0.72777em;vertical-align:-0.08333em;">&lt;/span>&lt;span class="mord">−&lt;/span>&lt;span class="mord">1&lt;/span>&lt;span class="mspace" style="margin-right:0.2222222222222222em;">&lt;/span>&lt;span class="mbin">⋅&lt;/span>&lt;span class="mspace" style="margin-right:0.2222222222222222em;">&lt;/span>&lt;/span>&lt;span class="base">&lt;span class="strut" style="height:0.625em;vertical-align:-0.19444em;">&lt;/span>&lt;span class="mord">&lt;span class="mord mathdefault">a&lt;/span>&lt;span class="msupsub">&lt;span class="vlist-t vlist-t2">&lt;span class="vlist-r">&lt;span class="vlist" style="height:0.31166399999999994em;">&lt;span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;">&lt;span class="pstrut" style="height:2.7em;">&lt;/span>&lt;span class="sizing reset-size6 size3 mtight">&lt;span class="mord mathdefault mtight">i&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;span class="vlist-s">​&lt;/span>&lt;/span>&lt;span class="vlist-r">&lt;span class="vlist" style="height:0.15em;">&lt;span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;span class="mpunct">,&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span> because in 0.32 fixed point, we have &lt;code>0x1_0000_0000 - a[i] = 0 - a[i]&lt;/code>. From this we get that inverting every second sample is equivalent to point-wise multiplication by the signal&lt;/p>
&lt;p>&lt;span class="katex-display">&lt;span class="katex">&lt;span class="katex-mathml">&lt;math xmlns="http://www.w3.org/1998/Math/MathML">&lt;semantics>&lt;mrow>&lt;mi>x&lt;/mi>&lt;mo stretchy="false">[&lt;/mo>&lt;mi>n&lt;/mi>&lt;mo stretchy="false">]&lt;/mo>&lt;mo>=&lt;/mo>&lt;mi mathvariant="normal">.&lt;/mi>&lt;mi mathvariant="normal">.&lt;/mi>&lt;mi mathvariant="normal">.&lt;/mi>&lt;mo>−&lt;/mo>&lt;mn>1&lt;/mn>&lt;mo separator="true">,&lt;/mo>&lt;mn>1&lt;/mn>&lt;mo separator="true">,&lt;/mo>&lt;mo>−&lt;/mo>&lt;mn>1&lt;/mn>&lt;mo separator="true">,&lt;/mo>&lt;mn>1...&lt;/mn>&lt;mo>=&lt;/mo>&lt;msup>&lt;mi>e&lt;/mi>&lt;mrow>&lt;mi>i&lt;/mi>&lt;mi>π&lt;/mi>&lt;mi>n&lt;/mi>&lt;/mrow>&lt;/msup>&lt;/mrow>&lt;annotation encoding="application/x-tex"> x[n] = ...-1,1,-1,1... = e^{i\pi n} &lt;/annotation>&lt;/semantics>&lt;/math>&lt;/span>&lt;span class="katex-html" aria-hidden="true">&lt;span class="base">&lt;span class="strut" style="height:1em;vertical-align:-0.25em;">&lt;/span>&lt;span class="mord mathdefault">x&lt;/span>&lt;span class="mopen">[&lt;/span>&lt;span class="mord mathdefault">n&lt;/span>&lt;span class="mclose">]&lt;/span>&lt;span class="mspace" style="margin-right:0.2777777777777778em;">&lt;/span>&lt;span class="mrel">=&lt;/span>&lt;span class="mspace" style="margin-right:0.2777777777777778em;">&lt;/span>&lt;/span>&lt;span class="base">&lt;span class="strut" style="height:0.66666em;vertical-align:-0.08333em;">&lt;/span>&lt;span class="mord">.&lt;/span>&lt;span class="mord">.&lt;/span>&lt;span class="mord">.&lt;/span>&lt;span class="mspace" style="margin-right:0.2222222222222222em;">&lt;/span>&lt;span class="mbin">−&lt;/span>&lt;span class="mspace" style="margin-right:0.2222222222222222em;">&lt;/span>&lt;/span>&lt;span class="base">&lt;span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;">&lt;/span>&lt;span class="mord">1&lt;/span>&lt;span class="mpunct">,&lt;/span>&lt;span class="mspace" style="margin-right:0.16666666666666666em;">&lt;/span>&lt;span class="mord">1&lt;/span>&lt;span class="mpunct">,&lt;/span>&lt;span class="mspace" style="margin-right:0.16666666666666666em;">&lt;/span>&lt;span class="mord">−&lt;/span>&lt;span class="mord">1&lt;/span>&lt;span class="mpunct">,&lt;/span>&lt;span class="mspace" style="margin-right:0.16666666666666666em;">&lt;/span>&lt;span class="mord">1&lt;/span>&lt;span class="mord">.&lt;/span>&lt;span class="mord">.&lt;/span>&lt;span class="mord">.&lt;/span>&lt;span class="mspace" style="margin-right:0.2777777777777778em;">&lt;/span>&lt;span class="mrel">=&lt;/span>&lt;span class="mspace" style="margin-right:0.2777777777777778em;">&lt;/span>&lt;/span>&lt;span class="base">&lt;span class="strut" style="height:0.8746639999999999em;vertical-align:0em;">&lt;/span>&lt;span class="mord">&lt;span class="mord mathdefault">e&lt;/span>&lt;span class="msupsub">&lt;span class="vlist-t">&lt;span class="vlist-r">&lt;span class="vlist" style="height:0.8746639999999999em;">&lt;span style="top:-3.113em;margin-right:0.05em;">&lt;span class="pstrut" style="height:2.7em;">&lt;/span>&lt;span class="sizing reset-size6 size3 mtight">&lt;span class="mord mtight">&lt;span class="mord mathdefault mtight">i&lt;/span>&lt;span class="mord mathdefault mtight" style="margin-right:0.03588em;">π&lt;/span>&lt;span class="mord mathdefault mtight">n&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/p>
&lt;p>which is your frequency shift in the time domain&lt;sup id="fnref:5">&lt;a href="#fn:5" class="footnote-ref" role="doc-noteref">5&lt;/a>&lt;/sup> operator set to &lt;span class="katex">&lt;span class="katex-mathml">&lt;math xmlns="http://www.w3.org/1998/Math/MathML">&lt;semantics>&lt;mrow>&lt;mi>π&lt;/mi>&lt;/mrow>&lt;annotation encoding="application/x-tex">\pi&lt;/annotation>&lt;/semantics>&lt;/math>&lt;/span>&lt;span class="katex-html" aria-hidden="true">&lt;span class="base">&lt;span class="strut" style="height:0.43056em;vertical-align:0em;">&lt;/span>&lt;span class="mord mathdefault" style="margin-right:0.03588em;">π&lt;/span>&lt;/span>&lt;/span>&lt;/span>, a half turn. This places all the negative frequencies into the positive part of spectrum, and because of the conjugate symmetry of real signal DFTs, they are the mirror image of the positive frequencies.&lt;/p>
&lt;p>DSP talk&amp;rsquo;s over. Intuitively, something like this &lt;em>should&lt;/em> happen&amp;ndash;low frequencies are slow movement, high frequencies are rapid movement. Forcing the sequence to repeatedly jump from one half to the other pushes all the frequencies higher.&lt;/p>
&lt;p>For &amp;lsquo;noise&amp;rsquo; this has the weird property that every second value is just the previous value flipped around &lt;span class="katex">&lt;span class="katex-mathml">&lt;math xmlns="http://www.w3.org/1998/Math/MathML">&lt;semantics>&lt;mrow>&lt;mn>0.5&lt;/mn>&lt;/mrow>&lt;annotation encoding="application/x-tex">0.5&lt;/annotation>&lt;/semantics>&lt;/math>&lt;/span>&lt;span class="katex-html" aria-hidden="true">&lt;span class="base">&lt;span class="strut" style="height:0.64444em;vertical-align:0em;">&lt;/span>&lt;span class="mord">0&lt;/span>&lt;span class="mord">.&lt;/span>&lt;span class="mord">5&lt;/span>&lt;/span>&lt;/span>&lt;/span>. A gray code round can get rid of that&amp;ndash;rightward invertible action of the bits like before by the way, this is a scramble. Shift here is by 6 because reserving the high bits preserves the frequency spectrum. That&amp;rsquo;s where all the energy in the signal is.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">kronecker_sequence&lt;/span>(i: u32, a: u32) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> u32:
&lt;span style="color:#66d9ef">return&lt;/span> u32(i) &lt;span style="color:#f92672">*&lt;/span> u32(a)
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">blue&lt;/span>(i: u32) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> u32:
s &lt;span style="color:#f92672">=&lt;/span> white_shuffle(i &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>)
b &lt;span style="color:#f92672">=&lt;/span> kronecker_sequence(s, &lt;span style="color:#ae81ff">2654435770&lt;/span>) &lt;span style="color:#75715e"># 0.31 fixed point golden ratio&lt;/span>
odd &lt;span style="color:#f92672">=&lt;/span> u32(i &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>)
b &lt;span style="color:#f92672">^=&lt;/span> (odd &lt;span style="color:#f92672">^&lt;/span> u32(&lt;span style="color:#ae81ff">1&lt;/span>)) &lt;span style="color:#f92672">-&lt;/span> u32(&lt;span style="color:#ae81ff">1&lt;/span>); &lt;span style="color:#75715e"># negate on odd indices&lt;/span>
b &lt;span style="color:#f92672">+=&lt;/span> odd
b &lt;span style="color:#f92672">^=&lt;/span> b &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> u32(&lt;span style="color:#ae81ff">6&lt;/span>) &lt;span style="color:#75715e"># gray code round&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> b
i &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>arange(&lt;span style="color:#ae81ff">3333&lt;/span>)
plots(&lt;span style="color:#e6db74">&amp;#34;blue&amp;#34;&lt;/span>, blue(i))
&lt;/code>&lt;/pre>&lt;/div>
&lt;div style="display: flex; justify-content: center;">
&lt;img src="https://graemephi.github.io/posts/some-low-discrepancy-noise-functions/blue.png" width="744" height="217" />
&lt;/div>
&lt;h3 id="observations-without-narrative-flow">Observations without narrative flow&lt;/h3>
&lt;blockquote class="aside">We can get red noise by not doing the inversion step. This duplicates every element, which is bad, but we can scramble every odd element. (Technically, scrambling is a thing you do to the values of a low discrepancy sequence, and shuffling a thing a thing you do to their indexes. In fixed point they are kind of duals to one another, at least when you have a proper scramble, like &lt;em>nested uniform scramble&lt;/em> is.) This raises the spectre of a scrambled odd value colliding with an unscrambled even value. None of this is ideal from a discrepancy point of view, but whatever.&lt;/blockquote>
&lt;blockquote class="aside">There is another purely real rotation we can do: a quarter turn of the frequency spectrum, using &lt;span class="katex-display">&lt;span class="katex">&lt;span class="katex-mathml">&lt;math xmlns="http://www.w3.org/1998/Math/MathML">&lt;semantics>&lt;mrow>&lt;msup>&lt;mi>e&lt;/mi>&lt;mrow>&lt;mi>i&lt;/mi>&lt;mi>π&lt;/mi>&lt;mi>n&lt;/mi>&lt;mi mathvariant="normal">/&lt;/mi>&lt;mn>2&lt;/mn>&lt;/mrow>&lt;/msup>&lt;mo>=&lt;/mo>&lt;mo>…&lt;/mo>&lt;mo>−&lt;/mo>&lt;mn>1&lt;/mn>&lt;mo separator="true">,&lt;/mo>&lt;mn>0&lt;/mn>&lt;mo separator="true">,&lt;/mo>&lt;mn>1&lt;/mn>&lt;mo separator="true">,&lt;/mo>&lt;mn>0&lt;/mn>&lt;mo separator="true">,&lt;/mo>&lt;mo>−&lt;/mo>&lt;mn>1&lt;/mn>&lt;mo separator="true">,&lt;/mo>&lt;mn>0&lt;/mn>&lt;mo separator="true">,&lt;/mo>&lt;mn>1&lt;/mn>&lt;mo>…&lt;/mo>&lt;/mrow>&lt;annotation encoding="application/x-tex">e^{i\pi n/2} = \ldots -1,0,1,0,-1,0,1 \ldots&lt;/annotation>&lt;/semantics>&lt;/math>&lt;/span>&lt;span class="katex-html" aria-hidden="true">&lt;span class="base">&lt;span class="strut" style="height:0.938em;vertical-align:0em;">&lt;/span>&lt;span class="mord">&lt;span class="mord mathdefault">e&lt;/span>&lt;span class="msupsub">&lt;span class="vlist-t">&lt;span class="vlist-r">&lt;span class="vlist" style="height:0.938em;">&lt;span style="top:-3.113em;margin-right:0.05em;">&lt;span class="pstrut" style="height:2.7em;">&lt;/span>&lt;span class="sizing reset-size6 size3 mtight">&lt;span class="mord mtight">&lt;span class="mord mathdefault mtight">i&lt;/span>&lt;span class="mord mathdefault mtight" style="margin-right:0.03588em;">π&lt;/span>&lt;span class="mord mathdefault mtight">n&lt;/span>&lt;span class="mord mtight">/&lt;/span>&lt;span class="mord mtight">2&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;span class="mspace" style="margin-right:0.2777777777777778em;">&lt;/span>&lt;span class="mrel">=&lt;/span>&lt;span class="mspace" style="margin-right:0.2777777777777778em;">&lt;/span>&lt;/span>&lt;span class="base">&lt;span class="strut" style="height:0.66666em;vertical-align:-0.08333em;">&lt;/span>&lt;span class="minner">…&lt;/span>&lt;span class="mspace" style="margin-right:0.2222222222222222em;">&lt;/span>&lt;span class="mbin">−&lt;/span>&lt;span class="mspace" style="margin-right:0.2222222222222222em;">&lt;/span>&lt;/span>&lt;span class="base">&lt;span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;">&lt;/span>&lt;span class="mord">1&lt;/span>&lt;span class="mpunct">,&lt;/span>&lt;span class="mspace" style="margin-right:0.16666666666666666em;">&lt;/span>&lt;span class="mord">0&lt;/span>&lt;span class="mpunct">,&lt;/span>&lt;span class="mspace" style="margin-right:0.16666666666666666em;">&lt;/span>&lt;span class="mord">1&lt;/span>&lt;span class="mpunct">,&lt;/span>&lt;span class="mspace" style="margin-right:0.16666666666666666em;">&lt;/span>&lt;span class="mord">0&lt;/span>&lt;span class="mpunct">,&lt;/span>&lt;span class="mspace" style="margin-right:0.16666666666666666em;">&lt;/span>&lt;span class="mord">−&lt;/span>&lt;span class="mord">1&lt;/span>&lt;span class="mpunct">,&lt;/span>&lt;span class="mspace" style="margin-right:0.16666666666666666em;">&lt;/span>&lt;span class="mord">0&lt;/span>&lt;span class="mpunct">,&lt;/span>&lt;span class="mspace" style="margin-right:0.16666666666666666em;">&lt;/span>&lt;span class="mord">1&lt;/span>&lt;span class="mspace" style="margin-right:0.16666666666666666em;">&lt;/span>&lt;span class="minner">…&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>You can fill in the zeros with another sequence generated with another shuffled Kronecker sequence. &lt;a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Martin Robert&amp;rsquo;s R2&lt;/a> works well. A quarter turn of red noise and a quarter turn of blue noise gets you green? and.. violet? I guess? noise? With the middle frequencies band-passed or cut. Unfortunately, it doesn&amp;rsquo;t extend to 2D using the technique I&amp;rsquo;m about to describe so I&amp;rsquo;m dropping it here. That it doesn&amp;rsquo;t work is interesting in its own right, I suppose.&lt;/blockquote>
&lt;blockquote class="aside">&lt;code>blue&lt;/code> doesn&amp;rsquo;t have equidistribution. That is, some inputs map to the same output. &lt;code>0&lt;/code> appears twice and who knows about &lt;code>0x8000_0000&lt;/code>. But it&amp;rsquo;s also lost an entire bit in the interleaving of two sequences. These are both length &lt;span class="katex">&lt;span class="katex-mathml">&lt;math xmlns="http://www.w3.org/1998/Math/MathML">&lt;semantics>&lt;mrow>&lt;msup>&lt;mn>2&lt;/mn>&lt;mn>32&lt;/mn>&lt;/msup>&lt;/mrow>&lt;annotation encoding="application/x-tex">2^{32}&lt;/annotation>&lt;/semantics>&lt;/math>&lt;/span>&lt;span class="katex-html" aria-hidden="true">&lt;span class="base">&lt;span class="strut" style="height:0.8141079999999999em;vertical-align:0em;">&lt;/span>&lt;span class="mord">&lt;span class="mord">2&lt;/span>&lt;span class="msupsub">&lt;span class="vlist-t">&lt;span class="vlist-r">&lt;span class="vlist" style="height:0.8141079999999999em;">&lt;span style="top:-3.063em;margin-right:0.05em;">&lt;span class="pstrut" style="height:2.7em;">&lt;/span>&lt;span class="sizing reset-size6 size3 mtight">&lt;span class="mord mtight">&lt;span class="mord mtight">3&lt;/span>&lt;span class="mord mtight">2&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span> and they interleave to a sequence of length &lt;span class="katex">&lt;span class="katex-mathml">&lt;math xmlns="http://www.w3.org/1998/Math/MathML">&lt;semantics>&lt;mrow>&lt;msup>&lt;mn>2&lt;/mn>&lt;mn>33&lt;/mn>&lt;/msup>&lt;/mrow>&lt;annotation encoding="application/x-tex">2^{33}&lt;/annotation>&lt;/semantics>&lt;/math>&lt;/span>&lt;span class="katex-html" aria-hidden="true">&lt;span class="base">&lt;span class="strut" style="height:0.8141079999999999em;vertical-align:0em;">&lt;/span>&lt;span class="mord">&lt;span class="mord">2&lt;/span>&lt;span class="msupsub">&lt;span class="vlist-t">&lt;span class="vlist-r">&lt;span class="vlist" style="height:0.8141079999999999em;">&lt;span style="top:-3.063em;margin-right:0.05em;">&lt;span class="pstrut" style="height:2.7em;">&lt;/span>&lt;span class="sizing reset-size6 size3 mtight">&lt;span class="mord mtight">&lt;span class="mord mtight">3&lt;/span>&lt;span class="mord mtight">3&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>. We only have 32 bits to index it with. Rounding the constants to have a zero bit in the last place (and a one bit in the second last place) gives us a pair of sequences of length &lt;span class="katex">&lt;span class="katex-mathml">&lt;math xmlns="http://www.w3.org/1998/Math/MathML">&lt;semantics>&lt;mrow>&lt;msup>&lt;mn>2&lt;/mn>&lt;mn>31&lt;/mn>&lt;/msup>&lt;/mrow>&lt;annotation encoding="application/x-tex">2^{31}&lt;/annotation>&lt;/semantics>&lt;/math>&lt;/span>&lt;span class="katex-html" aria-hidden="true">&lt;span class="base">&lt;span class="strut" style="height:0.8141079999999999em;vertical-align:0em;">&lt;/span>&lt;span class="mord">&lt;span class="mord">2&lt;/span>&lt;span class="msupsub">&lt;span class="vlist-t">&lt;span class="vlist-r">&lt;span class="vlist" style="height:0.8141079999999999em;">&lt;span style="top:-3.063em;margin-right:0.05em;">&lt;span class="pstrut" style="height:2.7em;">&lt;/span>&lt;span class="sizing reset-size6 size3 mtight">&lt;span class="mord mtight">&lt;span class="mord mtight">3&lt;/span>&lt;span class="mord mtight">1&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>. Now every value before the gray code round is even, but we know exactly what values we&amp;rsquo;re missing, the odd values, and what values we are double counting, the even values. I&amp;rsquo;m not bothered about that low bit, because we&amp;rsquo;re going to round it away anyway on conversion to float, and if you want integers, the high bits are better.&lt;/blockquote>
&lt;h2 id="2d-blue-noise">2D blue noise&lt;/h2>
&lt;p>Dumping it out in 2D doesn&amp;rsquo;t work, but the way it doesn&amp;rsquo;t work is instructive so let&amp;rsquo;s look at it.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">spectrum_2d&lt;/span>(img):
dft &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>abs(np&lt;span style="color:#f92672">.&lt;/span>fft&lt;span style="color:#f92672">.&lt;/span>fftshift(np&lt;span style="color:#f92672">.&lt;/span>fft&lt;span style="color:#f92672">.&lt;/span>fft2(img)))
dft &lt;span style="color:#f92672">/=&lt;/span> dft&lt;span style="color:#f92672">.&lt;/span>shape[&lt;span style="color:#ae81ff">0&lt;/span>]
&lt;span style="color:#66d9ef">return&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>clip(dft, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>)
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">lookit&lt;/span>(image):
f, ax &lt;span style="color:#f92672">=&lt;/span> plt&lt;span style="color:#f92672">.&lt;/span>subplots(figsize&lt;span style="color:#f92672">=&lt;/span>(&lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">*&lt;/span>image&lt;span style="color:#f92672">.&lt;/span>shape[&lt;span style="color:#ae81ff">0&lt;/span>]&lt;span style="color:#f92672">*&lt;/span>px, image&lt;span style="color:#f92672">.&lt;/span>shape[&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">*&lt;/span>px))
ax&lt;span style="color:#f92672">.&lt;/span>axis(&lt;span style="color:#e6db74">&amp;#39;off&amp;#39;&lt;/span>)
ax&lt;span style="color:#f92672">.&lt;/span>imshow(np&lt;span style="color:#f92672">.&lt;/span>hstack((image, spectrum_2d(image))))
n &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">384&lt;/span>
i &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>arange(n&lt;span style="color:#f92672">*&lt;/span>n)&lt;span style="color:#f92672">.&lt;/span>reshape((n,n))
noise &lt;span style="color:#f92672">=&lt;/span> blue(i) &lt;span style="color:#f92672">*&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>ldexp(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">32&lt;/span>)
lookit(noise)
&lt;/code>&lt;/pre>&lt;/div>
&lt;div style="display: flex; justify-content: center;">
&lt;img src="https://graemephi.github.io/posts/some-low-discrepancy-noise-functions/blue2d-bad.png" width="768" height="384" />
&lt;/div>
&lt;p>It&amp;rsquo;s blue horizontally, but in no other direction. Okay. At this point, we can generate another noise image, transpose it so it&amp;rsquo;s blue vertically, and drop it on top, like&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">noise[x,y] &lt;span style="color:#f92672">+&lt;/span> more_noise[y,x]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>and yeah it works but the spectrum isn&amp;rsquo;t that good and &lt;a href="https://en.wikipedia.org/wiki/Convolution_of_probability_distributions">the triangle distribution you get out of the sum&lt;/a> isn&amp;rsquo;t all that low-discrepancy either. If you don&amp;rsquo;t care about discrepancy, you could use some cheap PRNG here instead of low discrepancy noise and filter this right in a shader. Since you could design the filter to smooth out some of the anisotropy this method has, I think it could be pretty good.&lt;/p>
&lt;p>But to preserve low discrepancy we can decide that the issue is the path the noise takes over the image, and so let&amp;rsquo;s find a better path. I tried to find a way to do this with just arithmetic, and I got nowhere. But I did find a path that works that&amp;rsquo;s easy to compute offline, and it turns out we can tile the path. So this might be an okay compromise.&lt;/p>
&lt;p>No imaginative thinking here, horizontal path bad circular path good. This bins pixels into concentric rings, then pixels within each ring are sorted by their angle.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">spiral&lt;/span>(n: u32, lo: float, hi: float):
x, y &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>meshgrid(np&lt;span style="color:#f92672">.&lt;/span>linspace(lo, hi, n), np&lt;span style="color:#f92672">.&lt;/span>linspace(lo, hi, n))
&lt;span style="color:#75715e"># two sqrts: one for the distance, two to adjust for spirals closer to&lt;/span>
&lt;span style="color:#75715e"># the origin being tighter (think random sampling in a circle)&lt;/span>
xy &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>round(np&lt;span style="color:#f92672">.&lt;/span>sqrt(np&lt;span style="color:#f92672">.&lt;/span>sqrt(x&lt;span style="color:#f92672">*&lt;/span>x &lt;span style="color:#f92672">+&lt;/span> y&lt;span style="color:#f92672">*&lt;/span>y)) &lt;span style="color:#f92672">*&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>sqrt(n&lt;span style="color:#f92672">*&lt;/span>n &lt;span style="color:#f92672">+&lt;/span> n&lt;span style="color:#f92672">*&lt;/span>n))
&lt;span style="color:#75715e"># rescaled to a reasonable range that makes debugging possible without&lt;/span>
&lt;span style="color:#75715e"># a third eye&lt;/span>
angles &lt;span style="color:#f92672">=&lt;/span> (np&lt;span style="color:#f92672">.&lt;/span>arctan2(y, x) &lt;span style="color:#f92672">+&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>pi) &lt;span style="color:#f92672">/&lt;/span> (&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">*&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>pi)
&lt;span style="color:#75715e"># sort by magnitudes then angles (I don&amp;#39;t know why lexsort is&lt;/span>
&lt;span style="color:#75715e"># little-endian), then invert the sort&lt;/span>
spiral &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>lexsort((angles&lt;span style="color:#f92672">.&lt;/span>flatten(), xy&lt;span style="color:#f92672">.&lt;/span>flatten()))&lt;span style="color:#f92672">.&lt;/span>argsort()
&lt;span style="color:#66d9ef">return&lt;/span> spiral&lt;span style="color:#f92672">.&lt;/span>reshape((n,n))
s &lt;span style="color:#f92672">=&lt;/span> spiral(n, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1.0&lt;/span>, &lt;span style="color:#ae81ff">1.0&lt;/span>)
noise &lt;span style="color:#f92672">=&lt;/span> blue(s) &lt;span style="color:#f92672">*&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>ldexp(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">32&lt;/span>)
lookit(noise)
&lt;/code>&lt;/pre>&lt;/div>
&lt;div style="display: flex; justify-content: center;">
&lt;img src="https://graemephi.github.io/posts/some-low-discrepancy-noise-functions/blue2d-stillbad.png" width="768" height="384" />
&lt;/div>
&lt;p>&amp;hellip; looks weird. Something to do with the origin. Don&amp;rsquo;t wanna think about it.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">s &lt;span style="color:#f92672">=&lt;/span> spiral(n, &lt;span style="color:#ae81ff">2.0&lt;/span>, &lt;span style="color:#ae81ff">4.0&lt;/span>)
noise &lt;span style="color:#f92672">=&lt;/span> blue(s) &lt;span style="color:#f92672">*&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>ldexp(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">32&lt;/span>)
lookit(noise)
&lt;/code>&lt;/pre>&lt;/div>
&lt;div style="display: flex; justify-content: center;">
&lt;img src="https://graemephi.github.io/posts/some-low-discrepancy-noise-functions/blue2d.png" width="768" height="384" />
&lt;/div>
&lt;p>Nice. One reason this path is hard to replicate/approximate using only arithmetic on x and y is that it wraps at the edges in a nice symmetry breaking way that I don&amp;rsquo;t really understand:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">spiral(&lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">2.0&lt;/span>, &lt;span style="color:#ae81ff">4.0&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code class="language-terminal" data-lang="terminal">[[ 0 2 1 6 10 20 19 32]
[ 4 3 7 12 11 21 34 33]
[ 5 8 14 13 23 22 35 47]
[ 9 16 15 25 24 37 36 48]
[18 17 27 26 39 38 49 56]
[30 29 28 41 40 51 50 57]
[31 44 43 42 53 52 59 58]
[46 45 55 54 62 61 60 63]]
&lt;/code>&lt;/pre>&lt;p>And here it is with a 64x64 path, tiled using the &lt;a href="https://en.wikipedia.org/wiki/Z-order_(curve)">z-order curve&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">left_shift_2&lt;/span>(x: u32) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> u32:
x &lt;span style="color:#f92672">=&lt;/span> (x &lt;span style="color:#f92672">^&lt;/span> (x &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">16&lt;/span>)) &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">0x0000ffff&lt;/span>
x &lt;span style="color:#f92672">=&lt;/span> (x &lt;span style="color:#f92672">^&lt;/span> (x &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>)) &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">0x00ff00ff&lt;/span>
x &lt;span style="color:#f92672">=&lt;/span> (x &lt;span style="color:#f92672">^&lt;/span> (x &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>)) &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">0x0f0f0f0f&lt;/span>
x &lt;span style="color:#f92672">=&lt;/span> (x &lt;span style="color:#f92672">^&lt;/span> (x &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>)) &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">0x33333333&lt;/span>
x &lt;span style="color:#f92672">=&lt;/span> (x &lt;span style="color:#f92672">^&lt;/span> (x &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>)) &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">0x55555555&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> u32(x)
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">z_order&lt;/span>(x: u32, y: u32) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> u32:
&lt;span style="color:#66d9ef">return&lt;/span> left_shift_2(x) &lt;span style="color:#f92672">+&lt;/span> (left_shift_2(y) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> u32(&lt;span style="color:#ae81ff">1&lt;/span>))
tile_bits &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span>
tile_n &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> tile_bits
tile_mask &lt;span style="color:#f92672">=&lt;/span> tile_n &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
tile_path &lt;span style="color:#f92672">=&lt;/span> spiral(tile_n, &lt;span style="color:#ae81ff">2.0&lt;/span>, &lt;span style="color:#ae81ff">4.0&lt;/span>)
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">blue_2d&lt;/span>(x: u32, y: u32) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> u32:
x_lo &lt;span style="color:#f92672">=&lt;/span> x &lt;span style="color:#f92672">&amp;amp;&lt;/span> tile_mask
y_lo &lt;span style="color:#f92672">=&lt;/span> y &lt;span style="color:#f92672">&amp;amp;&lt;/span> tile_mask
x_hi &lt;span style="color:#f92672">=&lt;/span> x &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> tile_bits
y_hi &lt;span style="color:#f92672">=&lt;/span> y &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> tile_bits
tile &lt;span style="color:#f92672">=&lt;/span> z_order(x_hi, y_hi)
i &lt;span style="color:#f92672">=&lt;/span> (tile &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> u32(&lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">*&lt;/span>tile_bits)) &lt;span style="color:#f92672">+&lt;/span> tile_path[y_lo, x_lo]
&lt;span style="color:#66d9ef">return&lt;/span> blue(i)
x, y &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>meshgrid(np&lt;span style="color:#f92672">.&lt;/span>arange(n), np&lt;span style="color:#f92672">.&lt;/span>arange(n))
noise &lt;span style="color:#f92672">=&lt;/span> blue_2d(x, y) &lt;span style="color:#f92672">*&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>ldexp(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">32&lt;/span>)
lookit(noise)
&lt;/code>&lt;/pre>&lt;/div>
&lt;div style="display: flex; justify-content: center;">
&lt;img src="https://graemephi.github.io/posts/some-low-discrepancy-noise-functions/blue2d-64.png" width="768" height="384" />
&lt;/div>
&lt;p>Histogram&amp;rsquo;s still good:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">plt&lt;span style="color:#f92672">.&lt;/span>hist(noise&lt;span style="color:#f92672">.&lt;/span>flatten(), &lt;span style="color:#ae81ff">384&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>
&lt;div style="display: flex; justify-content: center;">
&lt;img src="https://graemephi.github.io/posts/some-low-discrepancy-noise-functions/blue2d-64-hist.png" width="900" height="200" />
&lt;/div>
&lt;p>So that&amp;rsquo;s a 8KB lookup table that&amp;rsquo;s good for as much noise as you can index with an integer, and you can always &lt;a href="https://www.jcgt.org/published/0011/01/04/">get more more constants&lt;/a> to replace the golden ratio with if you need more. (I&amp;rsquo;m not super satisfied with this, I wanted 0KB). Also some tiling artifacts where there is a too consistent &lt;em>lack&lt;/em> of correlation between adjacent pixels at tile boundaries, which is weird to think about. If you didn&amp;rsquo;t see it forget I said anything!!&lt;/p>
&lt;p>Part of the reason this works at all is that the quality of the noise that we&amp;rsquo;re threading through the image is not, spectrum-wise, all that good. With better noise, not only do you see the tiling clearly, the spectrum is really no better&amp;ndash;it&amp;rsquo;s determined by the spiral function in a way I don&amp;rsquo;t understand. So I&amp;rsquo;m not sure if this could be extended to 3D with just a path. But even if it does, for higher dimensions I doubt it would work all that well without huge lookup tables, because as the number of dimensions goes up the number of edge voxels increase faster than the number of interior voxels.&lt;/p>
&lt;h2 id="dither-revisited">Dither revisited&lt;/h2>
&lt;p>Since we started with dither, here&amp;rsquo;s some real dither. Usually for dither you want triangular noise rather than uniform. Triangular refers to the shape of the histogram. Alan Wolfe has &lt;a href="https://www.shadertoy.com/view/4t2SDh">a nice way of getting a triangle distribution out of uniform noise&lt;/a> that perfectly preserves discrepancy, so I&amp;rsquo;m going to use that. Hastily converted to python:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">uniform_to_triangle_dist&lt;/span>(x):
&lt;span style="color:#75715e"># From demofox @ https://www.shadertoy.com/view/4t2SDh&lt;/span>
x &lt;span style="color:#f92672">=&lt;/span> (x &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0.5&lt;/span>) &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
orig &lt;span style="color:#f92672">=&lt;/span> x &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">2.0&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1.0&lt;/span>
nz &lt;span style="color:#f92672">=&lt;/span> orig &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
x[&lt;span style="color:#f92672">~&lt;/span>nz] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
x[nz] &lt;span style="color:#f92672">=&lt;/span> orig[nz] &lt;span style="color:#f92672">/&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>sqrt(np&lt;span style="color:#f92672">.&lt;/span>abs(orig[nz]))
x &lt;span style="color:#f92672">=&lt;/span> x &lt;span style="color:#f92672">-&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>sign(orig) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0.5&lt;/span>
x &lt;span style="color:#f92672">=&lt;/span> (x &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">0.5&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">0.5&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0.5&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> x
&lt;/code>&lt;/pre>&lt;/div>&lt;p>An alternative would be to use &lt;a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">R2&lt;/a> to get another noise value to add to the first, you only need an extra multiply after all the shuffling to get it. Yet another alternative would be use more noise offset by half a tile to obscure the tiling artifacts.&lt;/p>
&lt;p>&lt;a href="https://gist.github.com/graemephi/3a90bc543aa974f7de04fa100c66bdc2#file-ldnoise-py-L278">Code&amp;rsquo;s here&lt;/a>. Quantized to 4 bits with 2 bits of dither. The top row is a gradient we&amp;rsquo;re dithering and what you get quantizing without dithering. Then it&amp;rsquo;s left: uniform noise dither, right: triangle noise dither. And top to bottom: random, this post&amp;rsquo;s white noise, this post&amp;rsquo;s blue noise, and last I&amp;rsquo;ve put known-good &lt;a href="http://momentsingraphics.de/BlueNoise.html">void and cluster blue noise&lt;/a>.&lt;/p>
&lt;div style="display: flex; justify-content: center;">
&lt;img src="https://graemephi.github.io/posts/some-low-discrepancy-noise-functions/dither-gradient.png" width="1024" height="500" />
&lt;/div>
&lt;p>Yup, it dithers 👍 Not as good as a good texture, but that&amp;rsquo;s okay.&lt;/p>
&lt;p>The white noise&amp;hellip; I don&amp;rsquo;t know what I expected.&lt;/p>
&lt;h2 id="bonus">Bonus&lt;/h2>
&lt;p>The low bits of the spiral function have a blue spectrum:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">s &lt;span style="color:#f92672">=&lt;/span> (spiral(&lt;span style="color:#ae81ff">384&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">0.08&lt;/span>, &lt;span style="color:#ae81ff">0.08&lt;/span>) &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">7&lt;/span>) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>
lookit(s)
&lt;/code>&lt;/pre>&lt;/div>
&lt;div style="display: flex; justify-content: center;">
&lt;img src="https://graemephi.github.io/posts/some-low-discrepancy-noise-functions/spiral-low-bits.png" width="768" height="384" />
&lt;/div>
&lt;p>Which suggests maybe we can reverse the bits and get something interesting out?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">s &lt;span style="color:#f92672">=&lt;/span> u32(spiral(&lt;span style="color:#ae81ff">384&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">0.08&lt;/span>, &lt;span style="color:#ae81ff">0.08&lt;/span>))
s &lt;span style="color:#f92672">=&lt;/span> masked_xorshift(s, &lt;span style="color:#ae81ff">2&lt;/span>)
s &lt;span style="color:#f92672">^=&lt;/span> s &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
s &lt;span style="color:#f92672">=&lt;/span> reverse_bits32(s)
s &lt;span style="color:#f92672">=&lt;/span> nested_uniform_scramble(s)
lookit(s &lt;span style="color:#f92672">/&lt;/span> s&lt;span style="color:#f92672">.&lt;/span>max())
&lt;/code>&lt;/pre>&lt;/div>
&lt;div style="display: flex; justify-content: center;">
&lt;img src="https://graemephi.github.io/posts/some-low-discrepancy-noise-functions/permuted-spiral.png" width="768" height="384" />
&lt;/div>
&lt;p>Huh. Conceptually, this is just a reordering of pixels&amp;ndash;you could replace that divide by a shift to turn it into a true permutation. It&amp;rsquo;s not noise, though. I tried some things, like rotating some tiles, placing the origin of the spiral at the corners, adding random jitter to the magnitude and angles in &lt;code>spiral&lt;/code>, but nothing worked very well at getting rid of the obvious structure while maintaining the spectrum. This is interesting, though.&lt;/p>
&lt;h2 id="bonus-2">Bonus 2&lt;/h2>
&lt;p>I have no idea what is going on here.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">red&lt;/span>(i: u32) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> u32:
s &lt;span style="color:#f92672">=&lt;/span> white_shuffle(i &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>)
r &lt;span style="color:#f92672">=&lt;/span> kronecker_sequence(s, &lt;span style="color:#ae81ff">2654435770&lt;/span>) &lt;span style="color:#75715e"># 0.31 fixed point golden ratio&lt;/span>
r[(i &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">^=&lt;/span> r[(i &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> u32(&lt;span style="color:#ae81ff">6&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> r
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">red_2d&lt;/span>(x: u32, y: u32) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> u32:
&lt;span style="color:#75715e"># note the right shift--this isn&amp;#39;t z-order&lt;/span>
i &lt;span style="color:#f92672">=&lt;/span> left_shift_2(x) &lt;span style="color:#f92672">+&lt;/span> (left_shift_2(y) &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> u32(&lt;span style="color:#ae81ff">1&lt;/span>))
&lt;span style="color:#66d9ef">return&lt;/span> red(i)
noise &lt;span style="color:#f92672">=&lt;/span> red_2d(x, y) &lt;span style="color:#f92672">*&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>ldexp(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">32&lt;/span>)
lookit(noise)
&lt;/code>&lt;/pre>&lt;/div>
&lt;div style="display: flex; justify-content: center;">
&lt;img src="https://graemephi.github.io/posts/some-low-discrepancy-noise-functions/red2d.png" width="768" height="384" />
&lt;/div>
&lt;p>Histogram&amp;rsquo;s okay, too, but it&amp;rsquo;s pretty bad within the bins.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">plt&lt;span style="color:#f92672">.&lt;/span>hist(noise&lt;span style="color:#f92672">.&lt;/span>flatten(), &lt;span style="color:#ae81ff">384&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>
&lt;div style="display: flex; justify-content: center;">
&lt;img src="https://graemephi.github.io/posts/some-low-discrepancy-noise-functions/red2d-hist.png" width="900" height="200" />
&lt;/div>
&lt;h2 id="bottom-text">Bottom text&lt;/h2>
&lt;p>Here&amp;rsquo;s the &lt;a href="https://gist.github.com/graemephi/3a90bc543aa974f7de04fa100c66bdc2">code for this post&lt;/a> without all my words around it.&lt;/p>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>Also known as &amp;ldquo;linear&amp;rdquo;. Who comes up with this stuff?&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>An interesting reason to use the golden ratio sequence is it turns out it&amp;rsquo;s easy to come up with more constants&amp;ndash;that is, aside from the golden ratio&amp;ndash;that let you generate multiple streams of correlated noise cheaply. R2 is one way, and there are others. But it&amp;rsquo;s a whole thing.&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3" role="doc-endnote">
&lt;p>If it seems weird that I&amp;rsquo;m so singularly focused on this property of &lt;em>nested uniform scramble&lt;/em> it&amp;rsquo;s because I figured out &lt;code>masked_xorshift&lt;/code> before I found out about that paper, and I&amp;rsquo;m not sure I would have figured it out if I thought &lt;em>nested uniform scramble&lt;/em> was the model to follow.&lt;sup id="fnref:6">&lt;a href="#fn:6" class="footnote-ref" role="doc-noteref">6&lt;/a>&lt;/sup>&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4" role="doc-endnote">
&lt;p>This fact is pretty elementary DSP-wise but Bart Wronski&amp;rsquo;s post was the only thing I could find that discusses it at a high level without assuming you are the sort of person who thinks that negative frequencies are a reasonable idea.&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:5" role="doc-endnote">
&lt;p>I told you not to worry about it!! But I can&amp;rsquo;t find any explanation of this that isn&amp;rsquo;t laden down with DSP nonsense so while I&amp;rsquo;m at it: the DFT gives you a representation of a signal as a sum of scaled-and-shifted sine waves, right? And you shift a signal around in time and all the sine waves change phase, in lockstep with each other. In the DFT sine waves are encoded as complex numbers&amp;ndash;a magnitude for the sine wave&amp;rsquo;s scale, and an angle, for its phase&amp;ndash;and it just so happens that multiplying a complex number by unit complex numbers only modifies the angle. So shifting signals &lt;em>in time&lt;/em> can be done in the frequency domain by multiplying the complex coefficient of each sine wave by &lt;code>exp(1j * carefully_chosen_shift_amount_per_sine_wave * 2 * pi)&lt;/code>. The shorter the wavelength, the larger the shift, because shorter waves complete more of their cycle per unit time.
&lt;br>
&lt;br>
That&amp;rsquo;s shifting in time. If you do the &lt;em>exact same thing&lt;/em> in the time domain&amp;ndash;multiply the time domain samples by those unit complex numbers&amp;ndash;you shift the frequency components around. That&amp;rsquo;s shifting in frequency. Okay? Okay.&amp;#160;&lt;a href="#fnref:5" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:6" role="doc-endnote">
&lt;p>And the reason I keep italicizing &lt;em>nested uniform scramble&lt;/em> is because &lt;em>nested uniform scramble&lt;/em> is a nested uniform scramble. There are others, you see.&amp;#160;&lt;a href="#fnref:6" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item></channel></rss>